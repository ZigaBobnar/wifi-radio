%% Stil dokumenta povzet po: https://www.fe.uni-lj.si/izobrazevanje/studentska_pisarna/pravilniki_in_navodila/zakljucno_delo/

%%
%% Layout
%%
\documentclass[12pt,a4paper,twoside,openright,slovene]{book}
\usepackage[a4paper,left=2cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}

%%
%% Stil
%%
\usepackage[pdftex]{projektna_naloga} % Nalozi iz projektna_naloga.sty

%%
%% Jezik
%%
\usepackage[english,slovene]{babel} % Jeziki dokumenta - zadnji je primarni
\usepackage[utf8]{inputenc}

%%
%% PDF/A kompatibilnost
%%
% Glej: https://www.mathstat.dal.ca/~selinger/pdfa/
\usepackage{filecontents}
\begin{filecontents*}{\jobname.xmpdata}
    \Title{Wi-Fi Radio - Projektna naloga}
    \Author{Žiga Bobnar}
\end{filecontents*}
\usepackage[a-1b]{pdfx}

%%
%% LaTeX razsiritve
%%
% Kompakten pregled LaTeX ukazov je dostopen na https://en.wikibooks.org/wiki/Category:Book:LaTeX
% Navodila posameznih uporabljenih paketov so dostopna na https://www.ctan.org

% Dodatni simboli
\usepackage{textcomp}                               % dodatni simboli (kot npr. €)
\usepackage{gensymb}                                % dodatni simboli \de­gree, \cel­sius, \pert­hou­sand, \mi­cro, \ohm
\newcommand{\uppi}{\textrm{\greektext p\latintext}} % velika grška črka P z \uppi, alternativa simbolu \Pi

% Osnovno oblikovanje
\hypersetup{unicode,hidelinks,breaklinks,hyperindex} % dodatne možnosti hiperpovezav
\usepackage[normalem]{ulem}                          % podčrtavanje in prečrtavanje teksta
\usepackage{float}                                   % dodatne možnosti oblikovanja objektov
\usepackage{enumitem}                                % dodatne možnosti oblikovanja seznamov

% Dodatno oblikovanje
%\zamaknirobsodihstrani{0mm} % dodatna prilagoditev levega roba sodih strani za dvostranski tisk
%\usepackage{dcolumn}        % poravnava po decimalnih mestih v tabelah
\usepackage{longtable}      % večstranske tabele
%\usepackage{caption}        % dodatne možnosti označevanja objektov
%\usepackage{rotating}       % vretenje objektov, strani, ipd.

% Matematična orodja
\usepackage{mathtools} % http://mirrors.ctan.org/macros/LaTeX/contrib/mathtools/mathtools.pdf
\usepackage{bm}        % ukaz za odebeljeni tisk \bm v matematičnih okoljih
%\usepackage{cancel}   % ukaz za prečrtavanje \cancel v matematičnih okoljih

% Grafična orodja
\usepackage{graphicx}                 % vključevanje bitnih slik z ukazom \includegraphics
\usepackage{grffile}                  % podpora presledkom pri ukazu \includegraphics
%\usepackage{tikz}                    % paket TikZ za risanje (npr. blokovnih shem, diagramov poteka, itd.)
%\usetikzlibrary{calc,shapes,arrows}  % dodatne možnosti paketa TikZ
%\usepackage{tikzscale}               % skaliranje risb
%\usepackage[smartlabels]{circuitikz} % risanje shem vezij
%\usepackage{pgfplots}                % paket PGFPlots za risanje grafov, tudi iz CSV in podobnih datotek
%\usepgfplotslibrary{polar,external}  % dodatne možnosti paketa PGFPlots
%\usepackage{tikz-3dplot}             % 3D risanje
% Primeri: http://texample.net , http://pgfplots.net/tikz/examples , http://pgfplots.sourceforge.net/gallery.html

% Vključevanje datotek
\usepackage{pdfpages} % vključevanje PDF datotek z ukazom \includegraphics
\usepackage{epstopdf} % vključevanje EPS datotek z ukazom \includegraphics
\usepackage{listings} % orodja za izpisovanje programske kode
\lstset{              % nastavitve orodja za izpisovanje programske kode
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    numbers=left,
    numberstyle=\scriptsize,
    keywordstyle=\color{blue},
    commentstyle=\color{unilj},
    stringstyle=\color{olive},
}

%%
%% Podatki dokumenta
%%
\naslov{Wi-Fi radio}
\avtor{Žiga Bobnar}

\date{Ljubljana, Junij 2021}

\delo{Projektna naloga\\~\\Modul B - Vgrajeni sistemi\\~\\Univerzitetni študijski program prve stopnje Elektrotehnika}
\univerza{Univerza v Ljubljani}
\fakulteta{Fakulteta za elektrotehniko}
\definecolor{unilj}{cmyk}{0.00, 0.94, 0.94, 0.06} % barva Univerze v Ljubljani

%%
%% Vsebina
%%
\begin{document}
\frontmatter

\selectlanguage{slovene}

\maketitle

\tableofcontents

\mainmatter




\chapter{Predstavitev projekta} \label{predstavitev}
V tej projektni nalogi bom predstavil izdelavo predvajalnika glasbe z uporabo mikrokrmilnika. Pri tem je bil cilj kot izziv uporabiti brezžično komunikacijo preko Wi-Fi za prenos zvočnih podatkov. Hkrati pa sem si zastavil nekakšno omejitev, da za celoten projekt uporabim samo material, ki ga imam že na voljo doma, to pa pomeni brez uporabe kakšnih zelo namenskih čipov (na primer MP3 dekodirnik), z izjemo čipov, ki jih je možno enostavno "reciklirati" iz izrabljenih oziroma za današnje standarde zastarelih naprav (na primer star avtoradio).



\section{Zahteve projekta}
Končano prvo fazo projekta (domena te projektne naloge) tako interpretiram kot nekakšno osnovno implementacijo ideje (ang. proof of concept), ki lahko brezžično predvaja glasbo iz strežnika, na zahtevo ustavi predvajanje oziroma ga nadaljuje, zvok pa naj bo zadosti kvaliteten recimo za uporabo v kakšni delavnici (torej primerljiv z FM sprejemnikom, ne neka avdiofilska kvaliteta).

Končan izdelek naj bo tudi prenosljiv, torej napajanje iz baterije, za enostavnost pa predpostavljam da je polnjenje Li-Ion baterij izvedeno zunaj izdelka, saj bi bilo sicer potrebno poskrbeti za ustrezno zaščito baterij in elektronike.



\section{Osnovna struktura projekta}
Celoten projekt sem tekom razvoja razdelil na tri ločene segmente. Prvi del je razvojna ploščica Arduino Due (v nadaljevanju Due), na kateri je mikrokrmilnik Atmel SAM3X8E. To je 32-bitni ARM mikrokrmilniški sistem, ki je jedro projekta in opravlja večino nalog, na primer krmiljenje LCD zaslona, komunikacija z modulom za brezžično povezavo ter predvajanje zvoka preko vgrajenega DA (digitalno-analognega) pretvornika. Drugi del predstavlja modul za brezžično komunikacijo, in sicer sem uporabil modul ESP-01, na katerem je mikrokrmilnik Espressif ESP8266EX (v nadaljevanju samo ESP8266). Ploščico Due sem z modulom ESP8266 povezal preko UART vmesnika. Tretji in zadnji del projekta pa je enostaven računalniški program, ki deluje kot strežnik za pretakanje glasbe (z ustreznim kodiranjem in vzorčno frekvenco), obenem pa omogoča tudi na primer prenos podatkov o trenutnem času, s čimer se izognem potrebi po ročnem nastavljanju ure.



\section{Seznam uporabljenih elementov:} \label{uporabljeni_elementi}
\begin{itemize}
\item Razvojna ploščica Arduino DUE (s krmilnikom Atmel SAM3X8E)
\item Modul ESP-01 (s krmilnikom Espressif ESP8266EX)
\item Dupont žičke za hitro povezovanje prototip (ang. Dupont jumper wire)
\item Linearni regulator Motorola 7805CT (za zagotavljanje ustrezne 5 V napetosti za Arduino)
\item Integrirani audio ojačevalnik TDA2030 (izvor neznan, verjetno iz nekega avtoradia)
\item LCD zaslon, kompatibilen z vmesnikom Hitachi HD44780 (vzeto iz starega DVD predvajalnika)
\item 6 mm pritisni gumb (taktilna tipka, ang. tactile button, reciklirano iz starega avtoradia)
\item Li-Ion 3.7 V baterije tipa (dimenzije) 18650 z nominalno kapaciteto okrog 2400 mAh (baterije so pogosto uporabljene kot celice v  starejših akumulatorjih prenosnih računalnikov, kjer lahko ena slaba baterija povzroči, da postane na prvi pogled celoten akumulator  neuporaben, v resnici pa so nekatere posamezne celice lahko še povsem dobre, sploh za uporabo v nezahtevnih vezjih)
\item Zvočnik (v mojem primeru bo to manjši 4 ohmski zvočnik)
\item Ohišje (odločil sem se za 3D tiskanje ohišja, možna pa bi bila tudi uporaba lesa, plastičnih plošč, pločevine...)
\end{itemize}



\section{Projekt due-radio (Arduino Due)} \label{due_radio_projekt}
Za projekt sem uporabil znanje, enako programsko okolje (program Code::Blocks) ter kodo, ki smo jo pisali tekom laboratorijskih vaj pri  predmetu Programiranje vgrajenih sistemov (Modul B na univerzitetnem programu elektrotehnike). Koda je napisana v jeziku C.

Projekt sem tako izdelal po predlogi, ki vsebuje nastavitve prevajalnika in razhroščevanja za krmilnik SAM3X9E. Preko JTAG priključkov priključen vmesnik Olimex ARM-USB-OCD-H, ki deluje kot programator in razhroščevalnik in omogoča enostavnejše programiranje.

V tem projektu sem uporabljal določene knjižnice ASF (ang. Advanced software framework, prej tudi Atmel Software Framework), kar omogoča hitrejši razvoj funkcionalnosti z uporabo že pripravljenih metod, namesto direktne interakcije z registri (v nekaterih primerih pa je le-ta hitrejša). Te knjižnice so na primer \textit{clock}, \textit{delay}, \textit{ioport}, \textit{serial}, \textit{dacc}, \textit{pio}, \textit{tc}, \textit{uart} ter \textit{usart}.

Poleg teh knjižnic sem napisal oziroma dopolnjeval nekaj lastnih, ki smo jih razvijali na laboratorijskih vajah, primer tega so na primer gonilnik za LCD, FIFO vrsta (ang. first in, first out), gonilnik za DAC (bazira na obstoječem \textit{dacc} gonilniku iz ASF) ter serijski vmesniki za uporabo UART in USART komunikacije na višjih nivojih.


\subsection{Logična zgradba projekta} \label{due_radio_struktura_projekta}
Ker je s časom postalo dodajanje daljših kosov kode v datoteke, ki sicer nimajo veze z dejansko prvotno mišljeno funkcijo te datoteke (na primer beleženje napak v dnevnik dogodkov znotraj gonilnika za komunikacijo z Wi-Fi, za kar hitro postane precej nepraktično vsakič podvajati celotno kodo za pisanje neposredno v medpomnilnik dnevnika), sem se odločil za lažji razvoj postaviti nekakšno logično delitev in abstrakcijo kode, s tem pa možnost za enostavno prilagajanje obstoječe kode na novo strojno opremo (recimo povsem drugačen LCD, zunanji DAC).

Tako je možno sedaj razdeliti projekt na naslednje module (vse, kar je potrebno za uporabo kode enega modula v drugem modulu naj bi bila vključitev datoteke \textit{.h} modula in klic ustrezne funkcije):
\begin{itemize}
\item \textit{esp\_module.h}: Wi-Fi komunikacija, že glede na naslov projektne naloge verjetno najbolj ključen del celotnega projekta. Ta omogoča komunikacijo z modulom ESP-01, z uporabo strukturiranih ukazov in odzivov, preko serijskega vmesnika. Glavni problem te komunikacije je bila zagotovo visoka odzivnost, saj je za občutek realnočasnosti predvajanja posnetka potrebno zvočne vzorce v ustreznih intervalih nastavljati na izhod.
\item \textit{lcd.h}: LCD gonilnik za 16x2 zaslone, kompatibilne z HD44780 protokolom. Ta vsebuje funkcije za inicializacijo zaslona, čiščenje, nastavljanje besedila, poleg tega pa funkcije, ki so po funkcionalnosti zelo podobne funkciji \textit{printf} in omogoča zelo enostavno formatiranje besedila (vstavljanje vrednosti dinamičnih argumentov v predpripravljeni obliki).
\item \textit{dac.h}: DAC gonilnik, omogoča inicializacijo ter nastavljanje izhodnih vrednosti na izbrani kanal digitalno-analognega pretvornika.
\item \textit{fifo.h}: FIFO vrsta, omogoča ciklično branje do zadnjega zapisanega elementa ter pisanje do zadnjega prebranega elementa. Poleg tega pa omogoča tudi "kukanje" (ang. peek), kar poenostavi preverjanje naslednjega podatka brez odstranjevanja.
\item \textit{console.h in console\_definitions.h}: Serijska konzola. En od problemov programiranja tega projekta (več o tem v nadaljevanju), je omejeno število znakov, ki se lahko na zaslonu prikažejo. Za namene enostavnejšega pregleda nad dejanskim dogajanjem sem zato napisal vmesnik za komunikacijo z računalnikom preko serijske konzole. Ta vmesnik omogoča poleg pisanja besedila formatiranega podobno kot pri LCD gonilniku s stilom \textit{printf} tudi uporabo ukazov VT100, ki v večini modernih programov omogočajo spreminjanje barve besedila, torej je možno izdelati manj monoton pregled nad trenutnim stanjem.
\item \textit{timeguard.h}: Za potrebe omejevanja dovoljenega časa izvajanja nekaterih ukazov (na primer povezovanje v omrežje Wi-Fi, ki lahko traja), sem uporabil časovne števce, vgrajene v mikrokrmilnik. Z uporabo funkcij pa je možno pridobiti vrednost ustrezno skalirano v milisekunde oziroma sekunde. To omogoča, da lahko program, ki se izvaja v neskončni zanki prekine izvajanje, če je le-to predolgo.
\item \textit{buttons.h}: Gonilnik za odzivanje na pritiske gumbov. Uporabljen za človeško interakcijo s programom.
\end{itemize}



\section{Projekt modem-esp8266 (ESP8266)} \label{modem_esp8266_projekt}
Drugi del projekta kot že prej omenjeno sestavlja modul ESP-01. To je modul, ki se je na tržišču pojavil okrog leta 2014, vgrajen mikrokrmilnik pa med drugim omogoča povezavo in komunikacijo z Wi-Fi napravami, ki delujejo pri frekvencah 2.4 GHz (to pomeni, da mora biti ta način delovanja vključen na sodobnejših dostopnih točkah, ki omogočajo tudi delovanje pri frekvencah 5 GHz). Teoretično bi lahko uporabil sam mikrokrmilnik na ploščici (ESP8266) za brezžično predvajanje glasbe, ampak modul nima zadosti priključkov. Na različici 01 je samo 8 priključkov, od tega pa so samo 4 priključki na voljo za programirljive izhode, kar pomeni da bi bilo precej oteženo priključiti še kakšne tipke in zaslon.

Zaradi teh omejitev bo modul opravljal samo nekakšno vlogo modema, ki prek serijske povezave sprejema ukaze od Due in jih ustrezno interpretira ter pošlje po brezžičnem omrežju in vrne ustrezno oblikovan rezultat.

Projekt je izdelan v okolju PlatformIO, ki je popularna razširitev urejevalnika kode Visual Studio Code in omogoča programiranje velikega nabora vgrajenih sistemov. Za enostavnost (in ker sem želel čim večji fokus projekta posvetiti projektu na Due) sem kot osnovo uporabil knjižnice Arduino okolja, ki omogočajo enostavno sestavljanje besedilnih spremenljivk (ang. string). Poleg tega sem uporabil knjižnici \textit{ESP8266WiFi.h} in \textit{ESP8266HTTPClient.h}, napisani s strani proizvajalca čipa, ki omogočata enostavno povezovanje na dostopne točke in povezavno na HTTP strežnik.

Vsa koda projekta se nahaja v datoteki \textit{main.cpp} in vsebuje vse od inicializacije do procesiranja in izvajanja ukazov na enem mestu. Za ta pristop sem se odločil, ker se mi projekt zdi dovolj enostaven, da ločitev na več datotek še ni potrebna.



\section{Projekt wav-server (HTTP strežnik)} \label{wav_server_projekt}
Za delovanje prenosa glasbe, sem na začetku imel v mislih direktno povezavo na že obstoječe internetne radio postaje. Te pogosto prenašajo zvok v neki različici MP3 kodiranja. Problem pa je ne samo v omejeni procesorski zmogljivosti krmilnika, ampak tudi v mojem nepoznavanju celotnega kompleksnega procesa obdelave MP3 signala v surov avdio signal. Možna bi bila uporaba oziroma adaptacija kakšne že obstoječe kode, ki počne to pretvorbo, a sem se odločil za drugačen pristop.

Pri razvoju projekta je bilo potrebno vse skupaj kar velikokrat testirati. To pomeni, da je vsaka dodatna povezava na zunanji strežnik nova spremenljivka, na katero imamo malo vpliva in lahko prinaša frustracije, kadar ne deluje pravilno. Temu sem se sprva poskušal izogniti z lokalno namestitvijo programa, ki bi deloval na enak način kot tisti komercialni programi, ki jih uporabljajo radijske postaje. Problem se pojavi ker imajo vsi ti programi na zastonjski različici zelo omejene funkcionalnosti in je njihova konfiguracija veliko bolj zapletena, kot bi morala biti za enostavno pretakanje glasbe.

Zato sem v projekt dodal še tretji del, ki pravzaprav na zunaj izgleda kot čisto običajen HTTP strežnik, torej deluje na enakem protokolu kot običajne spletne strani. Izkoristil pa sem možnost programskega vračanja odziva tako, da lahko krmilnik zahteva s strežnika določen krajši segment izbranega posnetka (ang. chunk), vrne pa se kar neposredno zaporedje podatkov, kot bi bilo to kodirano v WAV formatu. WAV format omogoča precej bolj enostavno uporabo za nastavljanje izhoda, saj dejansko predstavlja zaporedne vrednosti v enakomernih intervalih s frekvenco vzorčenja (ang. sampling frequency). To pomneni, da potrebuje krmilnik samo pridobiti vrednosti posnetka in jih zaporedno v ustreznem časovnem intervalu nastavljati na izhod digitalno-analognega pretvornika. 

Ker se ta program izvaja na računalniku, ki je dovolj zmogljiv za višjenivojske jezike, sem se odločil za izdelavo projekta na osnovi okolja Node.js in sicer v skriptnem jeziku TypeScript. To je nadnabor (ang. superset) v spletnem svetu znanega jezika JavaScript. Za razliko od slednjega ima TypeScript med drugim sposobnost preverjanja veljavnosti tipa spremenljivk in sintakse, uporabo razredov (ang. class) in vmesnikov (ang. interface). Vse to omogoča precej enostavnejše odkrivanje napak v primerjavi z JavaScript kodo, hkrati pa je še vedno na precej visokem nivoju programiranja, tako da je programiranje relativno hitro.

Za moje potrebe najpomembnejša lastnost pa je to, da ima že ogromno izdelanih knjižnic s kodo. Z njihovo uporabo lahko zelo hitro izdelamo spletni strežnik, ki vrača sprogramirane dinamične odzive. Poleg tega pa obstajajo knjižnice za branje in operacije z WAV posnetki.





\chapter{Izdelava projekta} \label{izdelava}
V tem poglavju bom predstavil sam proces izdelave projekta. Skozi izdelavo ne bom šel v kronološkem zaporedju dejanskega razvoja, saj se je marsikatera funkcionalnost prepletala z drugimi. Poskusil pa bom opisati proces tako, da mu je možno slediti in ob tem v vsakem naslednjem delu dograjevati izdelek. Torej v vsakem poglavju bom poskusil izdelati nekakšen zaključen funkcionalni del izdelka.



\section{Krmiljenje LCD zaslona}
Prva težava, ki se pojavi je opazovanje, kaj se z izdelkom dogaja. Za povratno informacijo je sicer možno z uporabo razhroščevalnika ustaviti program in spremljati dogajanje. Vendar pa to predstavlja zahtevo po računalniku. Precej bolj enostavno s stališča končnega uporabnika, je imeti že v sam izdelek vgrajen zaslon, ki lahko prikazuje trenutno stanje oziroma morebitne napake.


\subsection{LCD HD44780}
Izbrani LCD uporablja krmilnik kompatibilen s precej pogosto uporabljenim protokolom Hitachi HD44780. Ta krmilnik omogoča, da z ukazi lahko v zaslon zapišemo ustrezne vrednosti za prikaz besedila, po tem pa ne potrebujemo več skrbeti za periodično osveževanje samega zaslona, saj to dela vgrajen krmilnik. Poleg tega omogoča dva načina prenosa podatkov, 8-bitni ali dvakrat po 4-bitni. Zasloni tega tipa se lahko razlikujejo med seboj na različne načine, na primer število vrstic, število stolpcev, število pikslov na znak, barva ozadja, barva ospredja, možnost osvetlitve in barva osvetlitve. Najpogostejši so zasloni z znaki v 16 stolpcih in 2 vrsticah. 

Za samo analizo protokola je najboljše uporabiti kar dokumentacijo proizvajalca (oziroma kar izvornega HD44780), ki jo je možno dobiti na internetu. Za pošiljanje ukazov v sam zaslon so pomembni priključki E (Enable), RS (Register select), R/W (Read/Write) in podatkovne linije D7-D0. Kadar ima RS logično vrednost 0 pomeni uporabo ukaznega registra, pri vrednosti 1 pa je aktiven podatkovni register (za znake). Kadar je R/W enak 0, je zaslon konfiguriran za branje v smeri iz zaslona, za vrednost 1 pomeni pisanje v zaslon (naj bo to ukaz ali pa vrednost znaka). Za prenos vsake vrednosti v zaslon moramo linijo E za kratek čas postaviti na vrednost 1 in nato nazaj na 0.

Seznam ukazov in določenih argumentov je prikazan v spodnji tabeli (povzeto po dokumentaciji):

\begin{footnotesize}
	\begin{center}
        \begin{longtable}{lccl}
            \caption{Ukazi za HD44780 (ang. instruction set)}
            \label{instruction_set_HD44780} \\
            Instruction                                 & RS    & R/W   & D7-D0     \\ \hline \hline
            Clear display                               & 0     & 0     & 0000 0001 \\ \hline
            Return home                                 & 0     & 0     & 0000 001- \\ \hline
            Entry mode set                              & 0     & 0     & 0000 01IS \\
                  \multicolumn{3}{l}{\quad I = I/D==1 - increment } \\
                  \multicolumn{3}{l}{\quad I = I/D==0 - decrement} \\
                  \multicolumn{3}{l}{\quad S==1 - Accompanies display shift} \\ \hline
            Display on/off control                      & 0     & 0     & 0000 1DCB \\
                  \multicolumn{3}{l}{\quad D==1 - sets display on} \\
                  \multicolumn{3}{l}{\quad D==0 - sets display off} \\
                  \multicolumn{3}{l}{\quad C==1 - sets cursor on }\\
                  \multicolumn{3}{l}{\quad C==0 - sets cursor off }\\
                  \multicolumn{3}{l}{\quad B==1 - enables cursor blinking }\\
                  \multicolumn{3}{l}{\quad B==0 - disables cursor blinking} \\ \hline
            Cursor or display shift                     & 0     & 0     &   0001 SR-- \\
                  \multicolumn{3}{l}{\quad S = S/C==1 - display shift} \\
                  \multicolumn{3}{l}{\quad S = S/C==0 - cursor move} \\
                  \multicolumn{3}{l}{\quad R = R/L==1 - shift to the right} \\
                  \multicolumn{3}{l}{\quad R = R/L==0 - shift to the left} \\ \hline
            Function set                                & 0     & 0     & 001L NF-- \\
                  \multicolumn{3}{l}{\quad L = DL==1 - 8-bit data length mode} \\
                  \multicolumn{3}{l}{\quad L = DL==0 - 4-bit data length mode} \\
                  \multicolumn{3}{l}{\quad N==1 - 2 lines} \\
                  \multicolumn{3}{l}{\quad N==0 - 1 line} \\
                  \multicolumn{3}{l}{\quad F==1 - 5x10 dots character font} \\
                  \multicolumn{3}{l}{\quad F==0 - 5x8 dots character font} \\ \hline
            Set CGRAM address                           &0      & 0     & 01AA AAAA \\
                \multicolumn{3}{l}{\quad A = ACG - CGRAM address (character gen RAM)} \\ \hline
            Set DDRAM address                           & 0     & 0     & 1AAA AAAA \\
                \multicolumn{3}{l}{\quad A = ADD - DDRAM address (display data RAM)} \\ \hline
            Read busy flag address                      & 0     & 1     & BAAA AAAA \\
                \multicolumn{3}{l}{\quad B = BF==1 - internally operating} \\
                \multicolumn{3}{l}{\quad B = BF==0 - instructions acceptable} \\
                \multicolumn{3}{l}{\quad A = AC - Address counter} \\ \hline
            Write data to CG or DDRAM                   & 1     & 0     & [Write data value] \\ \hline
            Read data from CG or DDRAM                  & 1     & 1     & [Read data value] \\ \hline
        \end{longtable}
	\end{center}
\end{footnotesize}

Priključitev priključkov zaslona je možna na veliko različnih načinov. V mojem primeru sem se odločil uporabiti isto priključitev kot smo jo uporabljali na laboratorijskih vajah. Zaporedje priključkov na LCD je odvisno od samega tipa priključka (lahko 16 priključkov en za drugim, lahko pa v konektorju 8x2). Za natančno informacijo o zaporedju je pametno preveriti v dokumentaciji dejanskega zaslona. Običajno pa si vsaj glede oznak sledijo v zaporedju prikazanem v spodnji tabeli:

\begin{footnotesize}
	\begin{center}
        \begin{longtable}{rl|l|l}
            \caption{Priključitev LCD na Adruino Due} \\
            PIN & Oznaka & Arduino Due PIN & Opis priključka\\ \hline \hline
            1   & GND           & GND & Masa zaslona \\
            2   & VCC           & 5V  & Napajanje zaslona \\
            3   & V\small{o}    & GND & Nastavitev kontrasta \\
            4   & RS            & D51 (\textit{C.12}) & Register select \\
            5   & R/W           & D49 (\textit{C.14}) & Read/Write \\
            6   & E             & D47 (\textit{C.16}) & Enable \\
            7   & D0            & - & \\
            8   & D1            & - & \\
            9   & D2            & - & \\
            10  & D3            & - & \\
            11  & D4            & D50 (\textit{C.13}) & \\
            12  & D5            & D48 (\textit{C.15}) & \\
            13  & D6            & D46 (\textit{C.17}) & \\
            14  & D7            & D44 (\textit{C.19}) & \\
            15  & A (+)         & - & Anoda osvetlitve - pozitivni priključek\\
            16  & K (-)         & - & Katoda osvetlitve - negativni priključek\\
        \end{longtable}
	\end{center}
\end{footnotesize}

Ker pa sem želel ohraniti nekaj fleksibilnosti glede priključitve LCD zaslona, sem ustvaril strukturo za nastavitev priključkov, poleg priključkov pa vsebuje še pomnilnik za izpis znakov ter kazalce na začetek prve ter začetek druge vrstice (to pride velikokrat prav, kadar je potrebno prvo vrstico pustiti pri miru). Enostavna koda te strukture izgleda tako:

\lstset{language=C,numberstyle=\tiny}
\begin{lstlisting}
struct _lcd {
    uint32_t rs;
    uint32_t rw;
    uint32_t enable;

    uint32_t d4;
    uint32_t d5;
    uint32_t d6;
    uint32_t d7;

    char __lcd_buffer[33];
    char* _lcd_string;
    char* lcd_upper;
    char* lcd_lower;
};
typedef struct _lcd lcd_t;
\end{lstlisting}

V nizkonivojske funkcije se ne bom preveč poglabljal, saj je za običajno uporabo povsem dovolj uporaba "visokonivojskih" abstrakcij, kot je na primer inicializacija z \lstinline{void lcd_init(lcd_t* lcd)}, izpis medpomnilnika na zaslon \lstinline{void lcd_write_string(lcd_t* lcd)}, izpis znakovnega niza na zaslon \lstinline{void lcd_write_string(lcd_t* lcd, uint8_t* value)} ter funkcije za formatirano izpisovanje v zaslon \lstinline{void lcd_write_formatted(lcd_t* lcd, const char* format, ...)}, \lstinline{void lcd_write_upper_formatted(lcd_t* lcd, const char* format, ...)} in \lstinline{void lcd_write_lower_formatted(lcd_t* lcd, const char* format, ...)}. Poleg tega pa sta še funkciji za čiščenje vrstic \lstinline{void lcd_clear_upper(lcd_t* lcd)} in \lstinline{void lcd_clear_lower(lcd_t* lcd)}.

Omembe vredna je mogoče le implementacija pisanja v 4-bitnem načinu, kjer se najprej v zaslon pošljejo podatki D7-D4, nato pa takoj še D3-D0:

\begin{lstlisting}
void lcd_driver_raw_send(lcd_t* lcd, uint8_t value, bool is_command) {
    ioport_set_pin_level(lcd->rs, !is_command);
    ioport_set_pin_level(lcd->rw, 0);

    // Poslje bite D7-D4
    lcd_driver_raw_data_pins_set(lcd, value >> 4);

    //   Ekvivalent za 8-bitni nacin:
    // ioport_set_pin_level(lcd->d7, value & (1 << 7));
    // ioport_set_pin_level(lcd->d6, value & (1 << 6));
    // ioport_set_pin_level(lcd->d5, value & (1 << 5));
    // ioport_set_pin_level(lcd->d4, value & (1 << 4));

    lcd_driver_pulse_enable_pin(lcd);


    // Poslje bite D3-D0
    lcd_driver_raw_data_pins_set(lcd, value);

    //   Ekvivalent za 8-bitni nacin (d3 do d0 ne obstajajo v strukturi!):
    // ioport_set_pin_level(lcd->d3, value & (1 << 3));
    // ioport_set_pin_level(lcd->d2, value & (1 << 2));
    // ioport_set_pin_level(lcd->d1, value & (1 << 1));
    // ioport_set_pin_level(lcd->d0, value & (1 << 0));

    lcd_driver_pulse_enable_pin(lcd);
}
\end{lstlisting}


\subsection{\textit{lcd.h} referenca}

Visokonivojske funkcije:

\lstinline{void lcd_init(lcd_t* lcd)}\newline
Inicializira LCD gonilnik z uporabo podane strukture.

\lstinline{void lcd_write_lcd_string(lcd_t* lcd)}\newline
Pošlje vrednosti iz \lstinline{lcd->__lcd_buffer} v LCD.

\lstinline{void lcd_write_string(lcd_t* lcd, uint8_t* value)}\newline
Pošlje vrednosti iz \lstinline{value} v LCD.

\lstinline{void lcd_write_formatted(lcd_t* lcd, const char* format, ...)}\newline
Izpiše formatiran tekst na začetek zaslona in z možnostjo preliva v naslednjo vrstico.

\lstinline{void lcd_write_upper_formatted(lcd_t* lcd, const char* format, ...)}\newline
Izpiše formatiran tekst samo v zgornjo vrstico.

\lstinline{void lcd_write_lower_formatted(lcd_t* lcd, const char* format, ...)}\newline
Izpiše formatiran tekst samo v spodnjo vrstico.

\lstinline{void lcd_write_string_at_cursor(lcd_t* lcd, uint8_t* value, uint8_t length)}\newline
Izpiše tekst od trenutne pozicije kurzorja naprej.

\lstinline{void lcd_wait_busy_status(lcd_t* lcd)}\newline
Počaka, da LCD signalizira konec operacij.

\lstinline{void lcd_clear_upper(lcd_t* lcd)}\newline
Izprazni vsebino zgornje vrstice v \lstinline{lcd->__lcd_buffer}.

\lstinline{void lcd_clear_lower(lcd_t* lcd)}\newline
Izprazni vsebino spodnje vrstice v \lstinline{lcd->__lcd_buffer}.



\section{Implementacija DAC (digitalno-analognega pretvornika)}
DAC predstavlja povezavo med digitalnimi vrednostmi, ki jih lahko zapišemo z dvojiškimi vrednostmi (biti), z analognim svetom, kjer so signali zvezne veličine. Omogoča pretvorbo večbitnih vrednosti v diskretne analogne nivoje, katerih razlika je vedno manjša, čim višjo resolucijo ima pretvornik (število bitov pretvornika).


\subsection{Arduino Due DACC}
Arduino Due (oziroma SAM3X8E) ima že vgrajen in z zunanje strani dostopna dva kanala DAC. Ta dva kanala se nahajata na pinih DAC0 in DAC1. Krmiljenje pa poteka preko periferne enote dacc (ang. digital-to-analog converter controller) vgrajene v sam mikrokrmilnik. Krmilnik ima na voljo 12 bitov resolucije, dejansko pa bom zaradi enostavnosti uporabljal 8-bitne vrednosti, saj je le-te najbolj enostavno prenašati preko serijskih vmesnikov.

Podobno kot že za LCD gonilnik, sem za lažje konfiguriranje pripravil strukturo, ki vsebuje indeks kanala, določene nastavitve za območje vrednosti ter frekvenco vzorčenja za prožilnike (trenutno ni v implementirano):
\begin{lstlisting}
struct _dac {
    uint32_t channel;
    uint32_t max_value;
    uint32_t min_value;
    uint32_t sampling_frequency;
};
typedef struct _dac dac_t;
\end{lstlisting}

Kar se implementacije tiče je trenutno ta datoteka samo abstrakcija dejanske strojne opreme za enostavno in hitro interakcijo.


\subsection{\textit{dac.h} referenca}

\lstinline{void dac_init(dac_t* dac)}\newline
Inicializira DACC vmesnik.

\lstinline{bool dac_tx_ready(dac_t* dac)}\newline
Preveri, če je DACC pripravljen na naslednji podatek.

\lstinline{void dac_write(dac_t* dac, uint32_t value)}\newline
Nastavi vrednost v DACC medpomnilnik.



\section{FIFO vrsta (First in, first out)}
FIFO vrsta omogoča učinkovit način za hitro shranjevanje podatkov, ki bodo kasneje prebrani, v medpomnilnik. Pri tem ne prihaja do nobenih prilagajanj velikosti (ang. resizing), saj se podatki, ki so bili že prebrani lahko prepišejo. Osnovna struktura je torej sestavljena iz nekega kosa pomnilnika, namenjenega podatkom, podatka o velikosti tega kosa pomnilnika, ter dveh indeksov. Prvi predstavlja trenutno pozicijo branja, drugi pa pisanja.

Tako izgleda struktura:
\begin{lstlisting}
struct _fifo {
    uint32_t read_idx;
    uint32_t write_idx;
    uint32_t size;
    uint8_t* buffer;
};
typedef struct _fifo fifo_t;
\end{lstlisting}

Osnovna implementacija FIFO vrste je pisanje N znakov v medpomnilnik ter branje N znakov iz njega. Pisanje je dokaj trivialno, dokler imamo na voljo podatke, jih zapisujemo v pozicijo trenutnega indeksa pisanja in ga povečujemo, če pridemo indeksa, ki je enak velikosti vrste, pa se ponastavi nazaj na 0 in lahko pišemo naprej. Če je slučajno indeks pisanja en korak pred indeksom branja, pa se ustavimo, saj namreč ne želimo prepisati še neprebranih podatkov. Branje deluje na podoben način, povečujemo indeks branja, dokler ne pridemo do indeksa pisanja oziroma dokler ne preberemo željenega števila podatkov.

Kar sem opazil tekom razvoja je to, da je v osnovi čista FIFO vrsta lahko kar nekoliko omejujoča. Na primer ne vemo, če je nek podatek na voljo, če ne preberemo vsaj naslednjega podatka, s tem pa ta podatek ni več del FIFO vrste (razen če manipuliramo neposredno FIFO strukturo, kar pa mislim da ni pametno, saj precej hitro ob nepazljivostih lahko pride do kakšne napake in vrsta postane neuporabna). Manjka torej funkcija, ki bi omogočala "kukanje" (ang. peek) naslednjih N vrednosti in funkcija, ki preveri če sta indeksa branja in pisanja različna. Tudi implementacija teh dveh funkcij je dokaj enostavna, dodal pa sem še funkcijo za "ponastavitev" vrste, ki enostavno oba indeksa vrne na 0 in s tem počisti neprebrane podatke (podatki sicer še vedno ostanejo v pomnilniku, le FIFO funkcije ne morejo dostopati do njih!). S tem je implementacija FIFO vrste precej bolj prijazna za programiranje, možne pa so še raznorazne nadaljnje razširitve.



\subsection{\textit{fifo.h} referenca}

\lstinline{uint32_t fifo_read(fifo_t* fifo, uint8_t* data_buffer, uint32_t n)}\newline
Prebere \lstinline{n} vrednosti iz FIFO vrste v \lstinline{data_buffer}.

\lstinline{uint32_t fifo_peek(fifo_t* fifo, uint8_t* data_buffer, uint32_t n)}\newline
Prebere \lstinline{n} vrednosti iz FIFO vrste v \lstinline{data_buffer}, vendar brez premikanja bralnega indeksa naprej.

\lstinline{bool fifo_has_next_item(fifo_t* fifo)}\newline
Preveri in vrne, če ima FIFO vrsta na voljo vsaj en element.

\lstinline{uint32_t fifo_write(fifo_t* fifo, uint8_t* data_ptr, uint32_t n)}\newline
Zapiše \lstinline{n} vrednosti iz \lstinline{data_ptr} v FIFO vrsto.

\lstinline{uint32_t fifo_write_single(fifo_t* fifo, uint8_t value);}\newline
Zapiše vrednost \lstinline{value} v FIFO vrsto.

\lstinline{void fifo_discard(fifo_t* fifo)}\newline
Postavi indeksa branja in pisanja na 0.



\section{Konzola (komunikacija z računalnikom)}
Precej hitro se je pojavila težava, da je za vsako spremembo bilo potrebno postavljati točke zaustavitve programa (ang. breakpoint), kjer naj se program ustavi in lahko ročno spremljamo njegov potek. To lahko postane precej zamudno, kadar je potrebno spremljati spremenljivke realnega okolja (na primer povezavo na brezžično omrežje), sploh pa kadar je preko serijske povezave priključena še druga naprava, ki pošilja podatke (modem), kjer je ustavljanje programa za pregled podatkov zelo nepraktično. Zaradi tega sem se odločil implementirati komunikacijo z računalnikom, pri čemer lahko vidim vse, kar se dogaja v krmilniku.

Arduino Due ima priročno že povezan serijski vmesnik na USB pretvornik (ta je čip MEGA16u2, priključen pa je na micro USB konektor, ki je najbližje okroglega napajalnega vhoda - programming port). Komunikacija poteka v obliki protokola UART. Za branje podatkov sem priročno izkoristil prej implementirano FIFO vrsto, v katero se začasno shranjujejo podatki takoj, ko so dekodirani.

Poleg samega vmesnika za interakcijo z konzolo, sem dodal tudi definicije pogosto uporabljenih konstant v datoteko \textit{console\_definitions.h}. Te konstante so na primer nekatere standardne baud hitrosti prenosa podatkov po UART, posebni ASCII znaki ter VT100 ukazi. Veliko današnjih emulatorjev konzole (programske konzole) upošteva te ukaze, z njimi pa je možno spreminjati položaj kurzorja, brisanje znakov, nastavljanje barve ozadja in barve besedila, spreminjanje velikosti znakov in verjetno še kaj več. Ukazi so včasih imenovani tudi "ANSI escape codes", saj je prvi znak zaporedja vedno ASCII vrednost za "escape".

Zaenkrat je komunikacija s konzolo samo enosmerna, z dovolj truda bi pa verjetno bilo povsem možno izdelati ustrezen vmesnik, ki lahko upošteva tudi ukaze dobljene z računalnika. To pomeni, da bi bilo lahko možno na primer celotno testiranje nekoliko avtomatizirati. Seveda pa to ni cilj te faze projekta.

\subsection{\textit{console.h} referenca}

\lstinline{void console_init(void)}\newline
Inicializira konzolo z ustrezno baud hitrostjo in omogoči ustrezne izhodne priključke.

\lstinline{void console_enable(void)}\newline
Omogoči sprejemanje in oddajanje podatkov preko serijskega vmesnika.

\lstinline{void console_process_input(void)}\newline
NI implementirano! V prihodnje je tu lahko procesiranje vhodnih ukazov, ki pridejo po vmesniku iz računalnika.

\lstinline{void console_put_char(const uint8_t value)}\newline
Zapiše en znak v konzolo.

\lstinline{void console_put_raw_string(const char* str)}\newline
Zapiše niz znakov v konzolo.

\lstinline{void console_put_line(const char* str)}\newline
Zapiše niz znakov v konzolo in doda znak za novo vrstico na konec.

\lstinline{void console_put(const char* str)}\newline
Zapiše niz znakov v konzolo (ekvivalentno \lstinline{console_put_raw_string}).

\lstinline{void console_put_formatted(const char* format, ...)}\newline
Zapiše formatiran niz znakov v konzolo in doda novo vrstico na konec.

\lstinline{bool console_char_ready(void)}\newline
Preveri in vrne, če je v konzoli na voljo kakšen znak za sprejem.

\lstinline{void console_wait_until_char_ready(void)}\newline
Počaka, da je na voljo znak za sprejem.

\lstinline{uint8_t console_get_char(void)}\newline
Prebere znak iz medpomnilnika za sprejem.

\lstinline{uint8_t console_peek_char(void)}\newline
Prebere znak iz medpomnilnika za sprejem brez spreminjanja trenutne pozicije branja.



\section{Enostaven časovnik (timeguard)}

Ker se nekatere operacije lahko izvajajo dalj časa in pogosto preverjamo njihovo stanje v neskončni "while" zanki, se mi zdi pametno implementirati nek način, da po določenem času obupamo nad preverjanjem in določimo da je ukaz neuspešen.

Implementacija timeguard za delovanje uporablja interni časovni števec, omogoča pa branje trenutnih vrednosti časa v milisekundah in sekundah ter računanje razlike med trenutnim časom in podanim časom.


\subsection{\textit{timeguard.h} referenca}

\lstinline{void timeguard_init(void)}\newline
Inicializira ustrezne periferne enote za uporabo časovnega števca.

\lstinline{int32_t timeguard_get_time(void)}\newline
Prebere vrednost iz časovnega števca. Ta vrednost še ni skalirana.

\lstinline{int32_t timeguard_get_time_ms(void)}\newline
Prebere vrednost trenutnega časa v milisekundah.

\lstinline{int32_t timeguard_get_diff_ms(int32_t previous_time_ms)}\newline
Izračuna razliko med trenutnim in podanim časom v milisekundah.

\lstinline{int32_t timeguard_get_time_s(void)}\newline
Prebere vrednost trenutnega časa v sekundah.

\lstinline{int32_t timeguard_get_diff_s(int32_t previous_time_s)}\newline
Izračuna razliko med trenutnim in podanim časom v sekundah.






\end{document}
