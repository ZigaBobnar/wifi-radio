%% Stil dokumenta povzet po: https://www.fe.uni-lj.si/izobrazevanje/studentska_pisarna/pravilniki_in_navodila/zakljucno_delo/

%%
%% Layout
%%
\documentclass[12pt,a4paper,twoside,openright,slovene]{book}
\usepackage[a4paper,left=2cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}

%%
%% Stil
%%
\usepackage[pdftex]{projektna_naloga} % Nalozi iz projektna_naloga.sty

%%
%% Jezik
%%
\usepackage[english,slovene]{babel} % Jeziki dokumenta - zadnji je primarni
\usepackage[utf8]{inputenc}

%%
%% PDF/A kompatibilnost
%%
% Glej: https://www.mathstat.dal.ca/~selinger/pdfa/
\usepackage{filecontents}
\begin{filecontents*}{\jobname.xmpdata}
    \Title{Wi-Fi Radio - Projektna naloga}
    \Author{Žiga Bobnar}
\end{filecontents*}
\usepackage[a-1b]{pdfx}

%%
%% LaTeX razsiritve
%%
% Kompakten pregled LaTeX ukazov je dostopen na https://en.wikibooks.org/wiki/Category:Book:LaTeX
% Navodila posameznih uporabljenih paketov so dostopna na https://www.ctan.org

% Dodatni simboli
\usepackage{textcomp}                               % dodatni simboli (kot npr. €)
\usepackage{eurosym}
\usepackage{gensymb}                                % dodatni simboli \de­gree, \cel­sius, \pert­hou­sand, \mi­cro, \ohm
\newcommand{\uppi}{\textrm{\greektext p\latintext}} % velika grška črka P z \uppi, alternativa simbolu \Pi

% Osnovno oblikovanje
\hypersetup{unicode,hidelinks,breaklinks,hyperindex} % dodatne možnosti hiperpovezav
\usepackage[normalem]{ulem}                          % podčrtavanje in prečrtavanje teksta
\usepackage{float}                                   % dodatne možnosti oblikovanja objektov
\usepackage{enumitem}                                % dodatne možnosti oblikovanja seznamov

% Dodatno oblikovanje
%\zamaknirobsodihstrani{0mm} % dodatna prilagoditev levega roba sodih strani za dvostranski tisk
%\usepackage{dcolumn}        % poravnava po decimalnih mestih v tabelah
\usepackage{longtable}      % večstranske tabele
%\usepackage{caption}        % dodatne možnosti označevanja objektov
%\usepackage{rotating}       % vretenje objektov, strani, ipd.

% Matematična orodja
\usepackage{mathtools} % http://mirrors.ctan.org/macros/LaTeX/contrib/mathtools/mathtools.pdf
\usepackage{bm}        % ukaz za odebeljeni tisk \bm v matematičnih okoljih
%\usepackage{cancel}   % ukaz za prečrtavanje \cancel v matematičnih okoljih

% Grafična orodja
\usepackage{graphicx}                 % vključevanje bitnih slik z ukazom \includegraphics
\usepackage{grffile}                  % podpora presledkom pri ukazu \includegraphics
%\usepackage{tikz}                    % paket TikZ za risanje (npr. blokovnih shem, diagramov poteka, itd.)
%\usetikzlibrary{calc,shapes,arrows}  % dodatne možnosti paketa TikZ
%\usepackage{tikzscale}               % skaliranje risb
%\usepackage[smartlabels]{circuitikz} % risanje shem vezij
%\usepackage{pgfplots}                % paket PGFPlots za risanje grafov, tudi iz CSV in podobnih datotek
%\usepgfplotslibrary{polar,external}  % dodatne možnosti paketa PGFPlots
%\usepackage{tikz-3dplot}             % 3D risanje
% Primeri: http://texample.net , http://pgfplots.net/tikz/examples , http://pgfplots.sourceforge.net/gallery.html

% Vključevanje datotek
\usepackage{pdfpages} % vključevanje PDF datotek z ukazom \includegraphics
\usepackage{epstopdf} % vključevanje EPS datotek z ukazom \includegraphics
\usepackage{listings} % orodja za izpisovanje programske kode
\lstset{              % nastavitve orodja za izpisovanje programske kode
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    numbers=left,
    numberstyle=\scriptsize,
    keywordstyle=\color{blue},
    commentstyle=\color{unilj},
    stringstyle=\color{olive},
}

%%
%% Podatki dokumenta
%%
\naslov{Wi-Fi radio}
\avtor{Žiga Bobnar}

\date{Ljubljana, Junij 2021}

\delo{Projektna naloga\\~\\Modul B - Vgrajeni sistemi\\~\\Univerzitetni študijski program prve stopnje Elektrotehnika}
\univerza{Univerza v Ljubljani}
\fakulteta{Fakulteta za elektrotehniko}
\definecolor{unilj}{cmyk}{0.00, 0.94, 0.94, 0.06} % barva Univerze v Ljubljani

\lstset{language=C,numberstyle=\tiny,tabsize=4}

%%
%% Vsebina
%%
\begin{document}
\frontmatter

\selectlanguage{slovene}

\maketitle

\tableofcontents

\mainmatter




\chapter{Predstavitev projekta} \label{predstavitev}
V tej projektni nalogi bom predstavil izdelavo predvajalnika glasbe z uporabo mikrokrmilnika. Pri tem je bil cilj kot izziv uporabiti brezžično komunikacijo preko Wi-Fi za prenos zvočnih podatkov. Hkrati pa sem si zastavil nekakšno omejitev, da za celoten projekt uporabim samo material, ki ga imam že na voljo doma, to pa pomeni brez uporabe kakšnih zelo namenskih čipov (na primer MP3 dekodirnik), z izjemo čipov, ki jih je možno enostavno "reciklirati" iz izrabljenih oziroma za današnje standarde zastarelih naprav (na primer star avtoradio).



\section{Zahteve projekta}
Končano prvo fazo projekta (domena te projektne naloge) tako interpretiram kot nekakšno osnovno implementacijo ideje (ang. proof of concept), ki lahko brezžično predvaja glasbo iz strežnika, na zahtevo ustavi predvajanje oziroma ga nadaljuje, zvok pa naj bo zadosti kvaliteten recimo za uporabo v kakšni delavnici (torej primerljiv z FM sprejemnikom, ne neka avdiofilska kvaliteta).

Končan izdelek naj bo tudi prenosljiv, torej napajanje iz baterije, za enostavnost pa predpostavljam da je polnjenje Li-Ion baterij izvedeno zunaj izdelka, saj bi bilo sicer potrebno poskrbeti za ustrezno zaščito baterij in elektronike.



\section{Osnovna struktura projekta}
Celoten projekt sem tekom razvoja razdelil na tri ločene segmente. Prvi del je razvojna ploščica Arduino Due (v nadaljevanju Due), na kateri je mikrokrmilnik Atmel SAM3X8E. To je 32-bitni ARM mikrokrmilniški sistem, ki je jedro projekta in opravlja večino nalog, na primer krmiljenje LCD zaslona, komunikacija z modulom za brezžično povezavo ter predvajanje zvoka preko vgrajenega DA (digitalno-analognega) pretvornika. Drugi del predstavlja modul za brezžično komunikacijo, in sicer sem uporabil modul ESP-01, na katerem je mikrokrmilnik Espressif ESP8266EX (v nadaljevanju samo ESP8266). Ploščico Due sem z modulom ESP8266 povezal preko UART vmesnika. Tretji in zadnji del projekta pa je enostaven računalniški program, ki deluje kot strežnik za pretakanje glasbe (z ustreznim kodiranjem in vzorčno frekvenco), obenem pa omogoča tudi na primer prenos podatkov o trenutnem času, s čimer se izognem potrebi po ročnem nastavljanju ure.



\section{Seznam uporabljenih elementov:} \label{uporabljeni_elementi}
\begin{itemize}
\item Razvojna ploščica Arduino DUE (s krmilnikom Atmel SAM3X8E)
\item Modul ESP-01 (s krmilnikom Espressif ESP8266EX)
\item Dupont žičke za hitro povezovanje prototip (ang. Dupont jumper wire)
\item Linearni regulator Motorola 7805CT (za zagotavljanje ustrezne 5 V napetosti za Arduino)
\item Integrirani audio ojačevalnik TDA2030 (izvor neznan, verjetno iz nekega avtoradia)
\item LCD zaslon, kompatibilen z vmesnikom Hitachi HD44780 (vzeto iz starega DVD predvajalnika)
\item 6 mm pritisni gumb (taktilna tipka, ang. tactile button, reciklirano iz starega avtoradia)
\item Li-Ion 3.7 V baterije tipa (dimenzije) 18650 z nominalno kapaciteto okrog 2400 mAh (baterije so pogosto uporabljene kot celice v  starejših akumulatorjih prenosnih računalnikov, kjer lahko ena slaba baterija povzroči, da postane na prvi pogled celoten akumulator  neuporaben, v resnici pa so nekatere posamezne celice lahko še povsem dobre, sploh za uporabo v nezahtevnih vezjih)
\item Zvočnik (v mojem primeru bo to manjši 4 ohmski zvočnik)
\item Ohišje (odločil sem se za 3D tiskanje ohišja, možna pa bi bila tudi uporaba lesa, plastičnih plošč, pločevine...)
\end{itemize}



\section{Projekt due-radio (Arduino Due)} \label{due_radio_projekt}
Za projekt sem uporabil znanje, enako programsko okolje (program Code::Blocks) ter kodo, ki smo jo pisali tekom laboratorijskih vaj pri  predmetu Programiranje vgrajenih sistemov (Modul B na univerzitetnem programu elektrotehnike). Koda je napisana v jeziku C.

Projekt sem tako izdelal po predlogi, ki vsebuje nastavitve prevajalnika in razhroščevanja za krmilnik SAM3X9E. Preko JTAG priključkov priključen vmesnik Olimex ARM-USB-OCD-H, ki deluje kot programator in razhroščevalnik in omogoča enostavnejše programiranje.

V tem projektu sem uporabljal določene knjižnice ASF (ang. Advanced software framework, prej tudi Atmel Software Framework), kar omogoča hitrejši razvoj funkcionalnosti z uporabo že pripravljenih metod, namesto direktne interakcije z registri (v nekaterih primerih pa je le-ta hitrejša). Te knjižnice so na primer \textit{clock}, \textit{delay}, \textit{ioport}, \textit{serial}, \textit{dacc}, \textit{pio}, \textit{tc}, \textit{uart} ter \textit{usart}.

Poleg teh knjižnic sem napisal oziroma dopolnjeval nekaj lastnih, ki smo jih razvijali na laboratorijskih vajah, primer tega so na primer gonilnik za LCD, FIFO vrsta (ang. first in, first out), gonilnik za DAC (bazira na obstoječem \textit{dacc} gonilniku iz ASF) ter serijski vmesniki za uporabo UART in USART komunikacije na višjih nivojih.


\subsection{Logična zgradba projekta} \label{due_radio_struktura_projekta}
Ker je s časom postalo dodajanje daljših kosov kode v datoteke, ki sicer nimajo veze z dejansko prvotno mišljeno funkcijo te datoteke (na primer beleženje napak v dnevnik dogodkov znotraj gonilnika za komunikacijo z Wi-Fi, za kar hitro postane precej nepraktično vsakič podvajati celotno kodo za pisanje neposredno v medpomnilnik dnevnika), sem se odločil za lažji razvoj postaviti nekakšno logično delitev in abstrakcijo kode, s tem pa možnost za enostavno prilagajanje obstoječe kode na novo strojno opremo (recimo povsem drugačen LCD, zunanji DAC).

Tako je možno sedaj razdeliti projekt na naslednje module (vse, kar je potrebno za uporabo kode enega modula v drugem modulu naj bi bila vključitev datoteke \textit{.h} modula in klic ustrezne funkcije):
\begin{itemize}
\item \textit{esp\_module.h}: Wi-Fi komunikacija, že glede na naslov projektne naloge verjetno najbolj ključen del celotnega projekta. Ta omogoča komunikacijo z modulom ESP-01, z uporabo strukturiranih ukazov in odzivov, preko serijskega vmesnika. Glavni problem te komunikacije je bila zagotovo visoka odzivnost, saj je za občutek realnočasnosti predvajanja posnetka potrebno zvočne vzorce v ustreznih intervalih nastavljati na izhod.
\item \textit{audio\_player.h}: Predvajalnik glasbe, skrbi za prenos naslednjega segmenta posnetka, posredovanje trenutne vrednosti signala gonilniku digitalno-analognega pretvornika ter hranjenje informacij o predvajanem posnetku.
\item \textit{lcd.h}: LCD gonilnik za 16x2 zaslone, kompatibilne z HD44780 protokolom. Ta vsebuje funkcije za inicializacijo zaslona, čiščenje, nastavljanje besedila, poleg tega pa funkcije, ki so po funkcionalnosti zelo podobne funkciji \textit{printf} in omogoča zelo enostavno formatiranje besedila (vstavljanje vrednosti dinamičnih argumentov v predpripravljeni obliki).
\item \textit{dac.h}: DAC gonilnik, omogoča inicializacijo ter nastavljanje izhodnih vrednosti na izbrani kanal digitalno-analognega pretvornika.
\item \textit{fifo.h}: FIFO vrsta, omogoča ciklično branje do zadnjega zapisanega elementa ter pisanje do zadnjega prebranega elementa. Poleg tega pa omogoča tudi "kukanje" (ang. peek), kar poenostavi preverjanje naslednjega podatka brez odstranjevanja.
\item \textit{console.h in console\_definitions.h}: Serijska konzola. En od problemov programiranja tega projekta (več o tem v nadaljevanju), je omejeno število znakov, ki se lahko na zaslonu prikažejo. Za namene enostavnejšega pregleda nad dejanskim dogajanjem sem zato napisal vmesnik za komunikacijo z računalnikom preko serijske konzole. Ta vmesnik omogoča poleg pisanja besedila formatiranega podobno kot pri LCD gonilniku s stilom \textit{printf} tudi uporabo ukazov VT100, ki v večini modernih programov omogočajo spreminjanje barve besedila, torej je možno izdelati manj monoton pregled nad trenutnim stanjem.
\item \textit{timeguard.h}: Za potrebe omejevanja dovoljenega časa izvajanja nekaterih ukazov (na primer povezovanje v omrežje Wi-Fi, ki lahko traja), sem uporabil časovne števce, vgrajene v mikrokrmilnik. Z uporabo funkcij pa je možno pridobiti vrednost ustrezno skalirano v milisekunde oziroma sekunde. To omogoča, da lahko program, ki se izvaja v neskončni zanki prekine izvajanje, če je le-to predolgo.
\item \textit{buttons.h}: Gonilnik za odzivanje na pritiske gumbov. Uporabljen za človeško interakcijo s programom.
\end{itemize}



\section{Projekt modem-esp8266 (ESP8266)} \label{modem_esp8266_projekt}
Drugi del projekta kot že prej omenjeno sestavlja modul ESP-01. To je modul, ki se je na tržišču pojavil okrog leta 2014, vgrajen mikrokrmilnik pa med drugim omogoča povezavo in komunikacijo z Wi-Fi napravami, ki delujejo pri frekvencah 2.4 GHz (to pomeni, da mora biti ta način delovanja vključen na sodobnejših dostopnih točkah, ki omogočajo tudi delovanje pri frekvencah 5 GHz). Teoretično bi lahko uporabil sam mikrokrmilnik na ploščici (ESP8266) za brezžično predvajanje glasbe, ampak modul nima zadosti priključkov. Na različici 01 je samo 8 priključkov, od tega pa so samo 4 priključki na voljo za programirljive izhode, kar pomeni da bi bilo precej oteženo priključiti še kakšne tipke in zaslon.

Zaradi teh omejitev bo modul opravljal samo nekakšno vlogo modema, ki prek serijske povezave sprejema ukaze od Due in jih ustrezno interpretira ter pošlje po brezžičnem omrežju in vrne ustrezno oblikovan rezultat.

Projekt je izdelan v okolju PlatformIO, ki je popularna razširitev urejevalnika kode Visual Studio Code in omogoča programiranje velikega nabora vgrajenih sistemov. Za enostavnost (in ker sem želel čim večji fokus projekta posvetiti projektu na Due) sem kot osnovo uporabil knjižnice Arduino okolja, ki omogočajo enostavno sestavljanje besedilnih spremenljivk (ang. string). Poleg tega sem uporabil knjižnici \textit{ESP8266WiFi.h} in \textit{ESP8266HTTPClient.h}, napisani s strani proizvajalca čipa, ki omogočata enostavno povezovanje na dostopne točke in povezavno na HTTP strežnik.

Vsa koda projekta se nahaja v datoteki \textit{main.cpp} in vsebuje vse od inicializacije do procesiranja in izvajanja ukazov na enem mestu. Za ta pristop sem se odločil, ker se mi projekt zdi dovolj enostaven, da ločitev na več datotek še ni potrebna.



\section{Projekt wav-server (HTTP strežnik)} \label{wav_server_projekt}
Za delovanje prenosa glasbe, sem na začetku imel v mislih direktno povezavo na že obstoječe internetne radio postaje. Te pogosto prenašajo zvok v neki različici MP3 kodiranja. Problem pa je ne samo v omejeni procesorski zmogljivosti krmilnika, ampak tudi v mojem nepoznavanju celotnega kompleksnega procesa obdelave MP3 signala v surov avdio signal. Možna bi bila uporaba oziroma adaptacija kakšne že obstoječe kode, ki počne to pretvorbo, a sem se odločil za drugačen pristop.

Pri razvoju projekta je bilo potrebno vse skupaj kar velikokrat testirati. To pomeni, da je vsaka dodatna povezava na zunanji strežnik nova spremenljivka, na katero imamo malo vpliva in lahko prinaša frustracije, kadar ne deluje pravilno. Temu sem se sprva poskušal izogniti z lokalno namestitvijo programa, ki bi deloval na enak način kot tisti komercialni programi, ki jih uporabljajo radijske postaje. Problem se pojavi ker imajo vsi ti programi na zastonjski različici zelo omejene funkcionalnosti in je njihova konfiguracija veliko bolj zapletena, kot bi morala biti za enostavno pretakanje glasbe.

Zato sem v projekt dodal še tretji del, ki pravzaprav na zunaj izgleda kot čisto običajen HTTP strežnik, torej deluje na enakem protokolu kot običajne spletne strani. Izkoristil pa sem možnost programskega vračanja odziva tako, da lahko krmilnik zahteva s strežnika določen krajši segment izbranega posnetka (ang. chunk), vrne pa se kar neposredno zaporedje podatkov, kot bi bilo to kodirano v WAV formatu. WAV format omogoča precej bolj enostavno uporabo za nastavljanje izhoda, saj dejansko predstavlja zaporedne vrednosti v enakomernih intervalih s frekvenco vzorčenja (ang. sampling frequency). To pomneni, da potrebuje krmilnik samo pridobiti vrednosti posnetka in jih zaporedno v ustreznem časovnem intervalu nastavljati na izhod digitalno-analognega pretvornika. 

Ker se ta program izvaja na računalniku, ki je dovolj zmogljiv za višjenivojske jezike, sem se odločil za izdelavo projekta na osnovi okolja Node.js in sicer v skriptnem jeziku TypeScript. To je nadnabor (ang. superset) v spletnem svetu znanega jezika JavaScript. Za razliko od slednjega ima TypeScript med drugim sposobnost preverjanja veljavnosti tipa spremenljivk in sintakse, uporabo razredov (ang. class) in vmesnikov (ang. interface). Vse to omogoča precej enostavnejše odkrivanje napak v primerjavi z JavaScript kodo, hkrati pa je še vedno na precej visokem nivoju programiranja, tako da je programiranje relativno hitro.

Za moje potrebe najpomembnejša lastnost pa je to, da ima že ogromno izdelanih knjižnic s kodo. Z njihovo uporabo lahko zelo hitro izdelamo spletni strežnik, ki vrača sprogramirane dinamične odzive. Poleg tega pa obstajajo knjižnice za branje in operacije z WAV posnetki.





\chapter{Izdelava projekta} \label{izdelava}
V tem poglavju bom predstavil sam proces izdelave projekta. Skozi izdelavo ne bom šel v kronološkem zaporedju dejanskega razvoja, saj se je marsikatera funkcionalnost prepletala z drugimi. Poskusil pa bom opisati proces tako, da mu je možno slediti in ob tem v vsakem naslednjem delu dograjevati izdelek. Torej v vsakem poglavju bom poskusil izdelati nekakšen zaključen funkcionalni del izdelka.



\section{Krmiljenje LCD zaslona}
Prva težava, ki se pojavi je opazovanje, kaj se z izdelkom dogaja. Za povratno informacijo je sicer možno z uporabo razhroščevalnika ustaviti program in spremljati dogajanje. Vendar pa to predstavlja zahtevo po računalniku. Precej bolj enostavno s stališča končnega uporabnika, je imeti že v sam izdelek vgrajen zaslon, ki lahko prikazuje trenutno stanje oziroma morebitne napake.


\subsection{LCD HD44780}
Izbrani LCD uporablja krmilnik kompatibilen s precej pogosto uporabljenim protokolom Hitachi HD44780. Ta krmilnik omogoča, da z ukazi lahko v zaslon zapišemo ustrezne vrednosti za prikaz besedila, po tem pa ne potrebujemo več skrbeti za periodično osveževanje samega zaslona, saj to dela vgrajen krmilnik. Poleg tega omogoča dva načina prenosa podatkov, 8-bitni ali dvakrat po 4-bitni. Zasloni tega tipa se lahko razlikujejo med seboj na različne načine, na primer število vrstic, število stolpcev, število pikslov na znak, barva ozadja, barva ospredja, možnost osvetlitve in barva osvetlitve. Najpogostejši so zasloni z znaki v 16 stolpcih in 2 vrsticah. 

Za samo analizo protokola je najboljše uporabiti kar dokumentacijo proizvajalca (oziroma kar izvornega HD44780), ki jo je možno dobiti na internetu. Za pošiljanje ukazov v sam zaslon so pomembni priključki E (Enable), RS (Register select), R/W (Read/Write) in podatkovne linije D7-D0. Kadar ima RS logično vrednost 0 pomeni uporabo ukaznega registra, pri vrednosti 1 pa je aktiven podatkovni register (za znake). Kadar je R/W enak 0, je zaslon konfiguriran za branje v smeri iz zaslona, za vrednost 1 pomeni pisanje v zaslon (naj bo to ukaz ali pa vrednost znaka). Za prenos vsake vrednosti v zaslon moramo linijo E za kratek čas postaviti na vrednost 1 in nato nazaj na 0.

Seznam ukazov in določenih argumentov je prikazan v spodnji tabeli (povzeto po dokumentaciji):

\begin{footnotesize}
	\begin{center}
        \begin{longtable}{lccl}
            \caption{Ukazi za HD44780 (ang. instruction set)}
            \label{instruction_set_HD44780} \\
            Instruction                                 & RS    & R/W   & D7-D0     \\ \hline \hline
            Clear display                               & 0     & 0     & 0000 0001 \\ \hline
            Return home                                 & 0     & 0     & 0000 001- \\ \hline
            Entry mode set                              & 0     & 0     & 0000 01IS \\
                  \multicolumn{3}{l}{\quad I = I/D==1 - increment } \\
                  \multicolumn{3}{l}{\quad I = I/D==0 - decrement} \\
                  \multicolumn{3}{l}{\quad S==1 - Accompanies display shift} \\ \hline
            Display on/off control                      & 0     & 0     & 0000 1DCB \\
                  \multicolumn{3}{l}{\quad D==1 - sets display on} \\
                  \multicolumn{3}{l}{\quad D==0 - sets display off} \\
                  \multicolumn{3}{l}{\quad C==1 - sets cursor on }\\
                  \multicolumn{3}{l}{\quad C==0 - sets cursor off }\\
                  \multicolumn{3}{l}{\quad B==1 - enables cursor blinking }\\
                  \multicolumn{3}{l}{\quad B==0 - disables cursor blinking} \\ \hline
            Cursor or display shift                     & 0     & 0     &   0001 SR-- \\
                  \multicolumn{3}{l}{\quad S = S/C==1 - display shift} \\
                  \multicolumn{3}{l}{\quad S = S/C==0 - cursor move} \\
                  \multicolumn{3}{l}{\quad R = R/L==1 - shift to the right} \\
                  \multicolumn{3}{l}{\quad R = R/L==0 - shift to the left} \\ \hline
            Function set                                & 0     & 0     & 001L NF-- \\
                  \multicolumn{3}{l}{\quad L = DL==1 - 8-bit data length mode} \\
                  \multicolumn{3}{l}{\quad L = DL==0 - 4-bit data length mode} \\
                  \multicolumn{3}{l}{\quad N==1 - 2 lines} \\
                  \multicolumn{3}{l}{\quad N==0 - 1 line} \\
                  \multicolumn{3}{l}{\quad F==1 - 5x10 dots character font} \\
                  \multicolumn{3}{l}{\quad F==0 - 5x8 dots character font} \\ \hline
            Set CGRAM address                           &0      & 0     & 01AA AAAA \\
                \multicolumn{3}{l}{\quad A = ACG - CGRAM address (character gen RAM)} \\ \hline
            Set DDRAM address                           & 0     & 0     & 1AAA AAAA \\
                \multicolumn{3}{l}{\quad A = ADD - DDRAM address (display data RAM)} \\ \hline
            Read busy flag address                      & 0     & 1     & BAAA AAAA \\
                \multicolumn{3}{l}{\quad B = BF==1 - internally operating} \\
                \multicolumn{3}{l}{\quad B = BF==0 - instructions acceptable} \\
                \multicolumn{3}{l}{\quad A = AC - Address counter} \\ \hline
            Write data to CG or DDRAM                   & 1     & 0     & [Write data value] \\ \hline
            Read data from CG or DDRAM                  & 1     & 1     & [Read data value] \\ \hline
        \end{longtable}
	\end{center}
\end{footnotesize}

Priključitev priključkov zaslona je možna na veliko različnih načinov. V mojem primeru sem se odločil uporabiti isto priključitev kot smo jo uporabljali na laboratorijskih vajah. Zaporedje priključkov na LCD je odvisno od samega tipa priključka (lahko 16 priključkov en za drugim, lahko pa v konektorju 8x2). Za natančno informacijo o zaporedju je pametno preveriti v dokumentaciji dejanskega zaslona. Običajno pa si vsaj glede oznak sledijo v zaporedju prikazanem v spodnji tabeli:

\begin{footnotesize}
	\begin{center}
        \begin{longtable}{rl|l|l}
            \caption{Priključitev LCD na Adruino Due} \\
            PIN & Oznaka & Arduino Due PIN & Opis priključka\\ \hline \hline
            1   & GND           & GND & Masa zaslona \\
            2   & VCC           & 5V  & Napajanje zaslona \\
            3   & V\small{o}    & GND & Nastavitev kontrasta \\
            4   & RS            & D51 (\textit{C.12}) & Register select \\
            5   & R/W           & D49 (\textit{C.14}) & Read/Write \\
            6   & E             & D47 (\textit{C.16}) & Enable \\
            7   & D0            & - & \\
            8   & D1            & - & \\
            9   & D2            & - & \\
            10  & D3            & - & \\
            11  & D4            & D50 (\textit{C.13}) & \\
            12  & D5            & D48 (\textit{C.15}) & \\
            13  & D6            & D46 (\textit{C.17}) & \\
            14  & D7            & D44 (\textit{C.19}) & \\
            15  & A (+)         & - & Anoda osvetlitve - pozitivni priključek\\
            16  & K (-)         & - & Katoda osvetlitve - negativni priključek\\
        \end{longtable}
	\end{center}
\end{footnotesize}

Ker pa sem želel ohraniti nekaj fleksibilnosti glede priključitve LCD zaslona, sem ustvaril strukturo za nastavitev priključkov, poleg priključkov pa vsebuje še pomnilnik za izpis znakov ter kazalce na začetek prve ter začetek druge vrstice (to pride velikokrat prav, kadar je potrebno prvo vrstico pustiti pri miru). Enostavna koda te strukture izgleda tako:

\begin{lstlisting}
struct _lcd {
    uint32_t rs;
    uint32_t rw;
    uint32_t enable;

    uint32_t d4;
    uint32_t d5;
    uint32_t d6;
    uint32_t d7;

    char __lcd_buffer[33]; // Pomnilnik za znake na zaslonu
    char* _lcd_string;     // Kazalec na zacetek pomnilnika
    char* lcd_upper;       // Kazalec na zacetek prve vrstice
    char* lcd_lower;       // Kazalec na zacetek druge vrstice
};
typedef struct _lcd lcd_t;
\end{lstlisting}

V nizkonivojske funkcije se ne bom preveč poglabljal, saj je za običajno uporabo povsem dovolj uporaba "visokonivojskih" abstrakcij, kot je na primer inicializacija z \lstinline{void lcd_init(lcd_t* lcd)}, izpis medpomnilnika na zaslon \lstinline{void lcd_write_string(lcd_t* lcd)}, izpis znakovnega niza na zaslon \lstinline{void lcd_write_string(lcd_t* lcd, uint8_t* value)} ter funkcije za formatirano izpisovanje v zaslon \lstinline{void lcd_write_formatted(lcd_t* lcd, const char* format, ...)}, \lstinline{void lcd_write_upper_formatted(lcd_t* lcd, const char* format, ...)} in \lstinline{void lcd_write_lower_formatted(lcd_t* lcd, const char* format, ...)}. Poleg tega pa sta še funkciji za čiščenje vrstic \lstinline{void lcd_clear_upper(lcd_t* lcd)} in \lstinline{void lcd_clear_lower(lcd_t* lcd)}.

Omembe vredna je mogoče le implementacija pisanja v 4-bitnem načinu, kjer se najprej v zaslon pošljejo podatki D7-D4, nato pa takoj še D3-D0:

\begin{lstlisting}
void lcd_driver_raw_send(lcd_t* lcd, uint8_t value, bool is_command) {
    ioport_set_pin_level(lcd->rs, !is_command);
    ioport_set_pin_level(lcd->rw, 0);

    // Poslje bite D7-D4
    lcd_driver_raw_data_pins_set(lcd, value >> 4);

    //   Ekvivalent za 8-bitni nacin:
    // ioport_set_pin_level(lcd->d7, value & (1 << 7));
    // ioport_set_pin_level(lcd->d6, value & (1 << 6));
    // ioport_set_pin_level(lcd->d5, value & (1 << 5));
    // ioport_set_pin_level(lcd->d4, value & (1 << 4));

    lcd_driver_pulse_enable_pin(lcd);


    // Poslje bite D3-D0
    lcd_driver_raw_data_pins_set(lcd, value);

    //   Ekvivalent za 8-bitni nacin (d3 do d0 ne obstajajo v strukturi!):
    // ioport_set_pin_level(lcd->d3, value & (1 << 3));
    // ioport_set_pin_level(lcd->d2, value & (1 << 2));
    // ioport_set_pin_level(lcd->d1, value & (1 << 1));
    // ioport_set_pin_level(lcd->d0, value & (1 << 0));

    lcd_driver_pulse_enable_pin(lcd);
}
\end{lstlisting}


\subsection{\textit{lcd.h} referenca}

Visokonivojske funkcije:
\begin{itemize}
	\item[] \lstinline{void lcd_init(lcd_t* lcd)}\newline
		Inicializira LCD gonilnik z uporabo podane strukture.
	\item[] \lstinline{void lcd_write_lcd_string(lcd_t* lcd)}\newline
		Pošlje vrednosti iz \lstinline{lcd->__lcd_buffer} v LCD.
	\item[] \lstinline{void lcd_write_string(lcd_t* lcd, uint8_t* value)}\newline
		Pošlje vrednosti iz \lstinline{value} v LCD.
	\item[] \lstinline{void lcd_write_formatted(lcd_t* lcd, const char* format, ...)}\newline
		Izpiše formatiran tekst na začetek zaslona in z možnostjo preliva v naslednjo vrstico.
	\item[] \lstinline{void lcd_write_upper_formatted(lcd_t* lcd, const char* format, ...)}\newline
		Izpiše formatiran tekst samo v zgornjo vrstico.
	\item[] \lstinline{void lcd_write_lower_formatted(lcd_t* lcd, const char* format, ...)}\newline
		Izpiše formatiran tekst samo v spodnjo vrstico.
	\item[] \lstinline{void lcd_write_string_at_cursor(lcd_t* lcd, uint8_t* value, uint8_t length)}\newline
		Izpiše tekst od trenutne pozicije kurzorja naprej.
	\item[] \lstinline{void lcd_wait_busy_status(lcd_t* lcd)}\newline
		Počaka, da LCD signalizira konec operacij.
	\item[] \lstinline{void lcd_clear_upper(lcd_t* lcd)}\newline
		Izprazni vsebino zgornje vrstice v \lstinline{lcd->__lcd_buffer}.
	\item[] \lstinline{void lcd_clear_lower(lcd_t* lcd)}\newline
		Izprazni vsebino spodnje vrstice v \lstinline{lcd->__lcd_buffer}.
\end{itemize}


\section{Implementacija DAC (digitalno-analognega pretvornika)}
DAC predstavlja povezavo med digitalnimi vrednostmi, ki jih lahko zapišemo z dvojiškimi vrednostmi (biti), z analognim svetom, kjer so signali zvezne veličine. Omogoča pretvorbo večbitnih vrednosti v diskretne analogne nivoje, katerih razlika je vedno manjša, čim višjo resolucijo ima pretvornik (število bitov pretvornika).


\subsection{Arduino Due DACC}
Arduino Due (oziroma SAM3X8E) ima že vgrajen in z zunanje strani dostopna dva kanala DAC. Ta dva kanala se nahajata na pinih DAC0 in DAC1. Krmiljenje pa poteka preko periferne enote dacc (ang. digital-to-analog converter controller) vgrajene v sam mikrokrmilnik. Krmilnik ima na voljo 12 bitov resolucije, dejansko pa bom zaradi enostavnosti uporabljal 8-bitne vrednosti, saj je le-te najbolj enostavno prenašati preko serijskih vmesnikov.

Podobno kot že za LCD gonilnik, sem za lažje konfiguriranje pripravil strukturo, ki vsebuje indeks kanala, določene nastavitve za območje vrednosti ter frekvenco vzorčenja za prožilnike (trenutno ni v implementirano):
\begin{lstlisting}
struct _dac {
    uint32_t channel;            // Kanal DAC kontrolerja
    uint32_t max_value;          // Najvisja vrednost izhoda
    uint32_t min_value;          // Najnizja vrednost izhoda
    uint32_t sampling_frequency; // Frekvenca vzorcenja
};
typedef struct _dac dac_t;
\end{lstlisting}

Kar se implementacije tiče je trenutno ta datoteka samo abstrakcija dejanske strojne opreme za enostavno in hitro interakcijo.


\subsection{\textit{dac.h} referenca}

\begin{itemize}
	\item[] \lstinline{void dac_init(dac_t* dac)}\newline
		Inicializira DACC vmesnik.
	\item[] \lstinline{bool dac_tx_ready(dac_t* dac)}\newline
		Preveri, če je DACC pripravljen na naslednji podatek.
	\item[] \lstinline{void dac_write(dac_t* dac, uint32_t value)}\newline
		Nastavi vrednost v DACC medpomnilnik.
\end{itemize}


\section{FIFO vrsta (First in, first out)}
FIFO vrsta omogoča učinkovit način za hitro shranjevanje podatkov, ki bodo kasneje prebrani, v medpomnilnik. Pri tem ne prihaja do nobenih prilagajanj velikosti (ang. resizing), saj se podatki, ki so bili že prebrani lahko prepišejo. Osnovna struktura je torej sestavljena iz nekega kosa pomnilnika, namenjenega podatkom, podatka o velikosti tega kosa pomnilnika, ter dveh indeksov. Prvi predstavlja trenutno pozicijo branja, drugi pa pisanja.

Tako izgleda struktura FIFO vrste:
\begin{lstlisting}
struct _fifo {
    uint32_t read_idx;  // Trenutna pozicija za pisanje
    uint32_t write_idx; // Trenutna pozicija za branje
    uint32_t size;      // Stevilo elementov, ki jih vrsta hrani
    uint8_t* buffer;    // Pomnilnik velikosti size
};
typedef struct _fifo fifo_t;
\end{lstlisting}

Osnovna implementacija FIFO vrste je pisanje N znakov v medpomnilnik ter branje N znakov iz njega. Pisanje je dokaj trivialno, dokler imamo na voljo podatke, jih zapisujemo v pozicijo trenutnega indeksa pisanja in ga povečujemo, če pridemo indeksa, ki je enak velikosti vrste, pa se ponastavi nazaj na 0 in lahko pišemo naprej. Če je slučajno indeks pisanja en korak pred indeksom branja, pa se ustavimo, saj namreč ne želimo prepisati še neprebranih podatkov. Branje deluje na podoben način, povečujemo indeks branja, dokler ne pridemo do indeksa pisanja oziroma dokler ne preberemo željenega števila podatkov.

Kar sem opazil tekom razvoja je to, da je v osnovi čista FIFO vrsta lahko kar nekoliko omejujoča. Na primer ne vemo, če je nek podatek na voljo, če ne preberemo vsaj naslednjega podatka, s tem pa ta podatek ni več del FIFO vrste (razen če manipuliramo neposredno FIFO strukturo, kar pa mislim da ni pametno, saj precej hitro ob nepazljivostih lahko pride do kakšne napake in vrsta postane neuporabna). Manjka torej funkcija, ki bi omogočala "kukanje" (ang. peek) naslednjih N vrednosti in funkcija, ki preveri če sta indeksa branja in pisanja različna. Tudi implementacija teh dveh funkcij je dokaj enostavna, dodal pa sem še funkcijo za "ponastavitev" vrste, ki enostavno oba indeksa vrne na 0 in s tem počisti neprebrane podatke (podatki sicer še vedno ostanejo v pomnilniku, le FIFO funkcije ne morejo dostopati do njih!). S tem je implementacija FIFO vrste precej bolj prijazna za programiranje, možne pa so še raznorazne nadaljnje razširitve.



\subsection{\textit{fifo.h} referenca}

\begin{itemize}
	\item[] \lstinline{uint32_t fifo_read(fifo_t* fifo, uint8_t* data_buffer, uint32_t n)}\newline
		Prebere \lstinline{n} vrednosti iz FIFO vrste v \lstinline{data_buffer}.
	\item[] \lstinline{uint32_t fifo_peek(fifo_t* fifo, uint8_t* data_buffer, uint32_t n)}\newline
		Prebere \lstinline{n} vrednosti iz FIFO vrste v \lstinline{data_buffer}, vendar brez premikanja bralnega indeksa naprej.
	\item[] \lstinline{bool fifo_has_next_item(fifo_t* fifo)}\newline
		Preveri in vrne, če ima FIFO vrsta na voljo vsaj en element.
	\item[] \lstinline{uint32_t fifo_write(fifo_t* fifo, uint8_t* data_ptr, uint32_t n)}\newline
		Zapiše \lstinline{n} vrednosti iz \lstinline{data_ptr} v FIFO vrsto.
	\item[] \lstinline{uint32_t fifo_write_single(fifo_t* fifo, uint8_t value);}\newline
		Zapiše vrednost \lstinline{value} v FIFO vrsto.
	\item[] \lstinline{void fifo_discard(fifo_t* fifo)}\newline
		Postavi indeksa branja in pisanja na 0.
\end{itemize}


\section{Konzola (komunikacija z računalnikom)}
Precej hitro se je pojavila težava, da je za vsako spremembo bilo potrebno postavljati točke zaustavitve programa (ang. breakpoint), kjer naj se program ustavi in lahko ročno spremljamo njegov potek. To lahko postane precej zamudno, kadar je potrebno spremljati spremenljivke realnega okolja (na primer povezavo na brezžično omrežje), sploh pa kadar je preko serijske povezave priključena še druga naprava, ki pošilja podatke (modem), kjer je ustavljanje programa za pregled podatkov zelo nepraktično. Zaradi tega sem se odločil implementirati komunikacijo z računalnikom, pri čemer lahko vidim vse, kar se dogaja v krmilniku.

Arduino Due ima priročno že povezan serijski vmesnik na USB pretvornik (ta je čip MEGA16u2, priključen pa je na micro USB konektor, ki je najbližje okroglega napajalnega vhoda - programming port). Komunikacija poteka v obliki protokola UART. Za branje podatkov sem priročno izkoristil prej implementirano FIFO vrsto, v katero se začasno shranjujejo podatki takoj, ko so dekodirani.

Poleg samega vmesnika za interakcijo z konzolo, sem dodal tudi definicije pogosto uporabljenih konstant v datoteko \textit{console\_definitions.h}. Te konstante so na primer nekatere standardne baud hitrosti prenosa podatkov po UART, posebni ASCII znaki ter VT100 ukazi. Veliko današnjih emulatorjev konzole (programske konzole) upošteva te ukaze, z njimi pa je možno spreminjati položaj kurzorja, brisanje znakov, nastavljanje barve ozadja in barve besedila, spreminjanje velikosti znakov in verjetno še kaj več. Ukazi so včasih imenovani tudi "ANSI escape codes", saj je prvi znak zaporedja vedno ASCII vrednost za "escape".

Zaenkrat je komunikacija s konzolo samo enosmerna, z dovolj truda bi pa verjetno bilo povsem možno izdelati ustrezen vmesnik, ki lahko upošteva tudi ukaze dobljene z računalnika. To pomeni, da bi bilo lahko možno na primer celotno testiranje nekoliko avtomatizirati. Seveda pa to ni cilj te faze projekta.

\subsection{\textit{console.h} referenca}

\begin{itemize}
	\item[] \lstinline{void console_init(void)}\newline
		Inicializira konzolo z ustrezno baud hitrostjo in omogoči ustrezne izhodne priključke.
	\item[] \lstinline{void console_enable(void)}\newline
		Omogoči sprejemanje in oddajanje podatkov preko serijskega vmesnika.
	\item[] \lstinline{void console_process_input(void)}\newline
		\underline{NI implementirano!} V prihodnje je tu lahko procesiranje vhodnih ukazov, ki pridejo po vmesniku iz računalnika.
	\item[] \lstinline{void console_put_char(const uint8_t value)}\newline
		Zapiše en znak v konzolo.
	\item[] \lstinline{void console_put_raw_string(const char* str)}\newline
		Zapiše niz znakov v konzolo.
	\item[] \lstinline{void console_put_line(const char* str)}\newline
		Zapiše niz znakov v konzolo in doda znak za novo vrstico na konec.
	\item[] \lstinline{void console_put(const char* str)}\newline
		Zapiše niz znakov v konzolo (ekvivalentno \lstinline{console_put_raw_string}).
	\item[] \lstinline{void console_put_formatted(const char* format, ...)}\newline
		Zapiše formatiran niz znakov v konzolo in doda novo vrstico na konec.
	\item[] \lstinline{bool console_char_ready(void)}\newline
		Preveri in vrne, če je v konzoli na voljo kakšen znak za sprejem.
	\item[] \lstinline{void console_wait_until_char_ready(void)}\newline
		Počaka, da je na voljo znak za sprejem.
	\item[] \lstinline{uint8_t console_get_char(void)}\newline
		Prebere znak iz medpomnilnika za sprejem.
	\item[] \lstinline{uint8_t console_peek_char(void)}\newline
		Prebere znak iz medpomnilnika za sprejem brez spreminjanja trenutne pozicije branja.
\end{itemize}

\section{Enostaven časovnik (timeguard)}

Ker se nekatere operacije lahko izvajajo dalj časa in pogosto preverjamo njihovo stanje v neskončni "while" zanki, se mi zdi pametno implementirati nek način, da po določenem času obupamo nad preverjanjem in določimo da je ukaz neuspešen.

Implementacija timeguard za delovanje uporablja interni časovni števec, omogoča pa branje trenutnih vrednosti časa v milisekundah in sekundah ter računanje razlike med trenutnim časom in podanim časom.


\subsection{\textit{timeguard.h} referenca}

\begin{itemize}
	\item[] \lstinline{void timeguard_init(void)}\newline
		Inicializira ustrezne periferne enote za uporabo časovnega števca.
	\item[] \lstinline{int32_t timeguard_get_time(void)}\newline
		Prebere vrednost iz časovnega števca. Ta vrednost še ni skalirana.
	\item[] \lstinline{int32_t timeguard_get_time_ms(void)}\newline
		Prebere vrednost trenutnega časa v milisekundah.
	\item[] \lstinline{int32_t timeguard_get_diff_ms(int32_t previous_time_ms)}\newline
		Izračuna razliko med trenutnim in podanim časom v milisekundah.
	\item[] \lstinline{int32_t timeguard_get_time_s(void)}\newline
		Prebere vrednost trenutnega časa v sekundah.
	\item[] \lstinline{int32_t timeguard_get_diff_s(int32_t previous_time_s)}\newline
		Izračuna razliko med trenutnim in podanim časom v sekundah.
\end{itemize}



\section{Gonilnik za tipke}

Človeška interakcija z napravami je še najbolj enostavna za uporabo in implementacijo, če uporabimo tipke. Te večinoma omogočajo odlično taktilno povratno informacijo ob pritisku in sprostitvi (občuten klik ter zvok). V primerjavi z na primer zasloni na dotik, kjer je ta povratna informacija običajno vizualna, je tipke tudi veliko bolj enostavno uporabiti v električnem vezju, saj lahko samo preverjamo, kdaj je njihovo notranje stikalo sklenjeno in kdaj ne.

Naloga gonilnika za tipke je torej, da ustrezno reagira na spremembe stanja tipk. V vgrajenih napravah pri neposredni povezavi tipk na priključke mikrokrmilnika, lahko to delamo na vsaj dva različna načina. Prvi v ustreznih časovnih intervalih prebere stanja tipk, drugi pa lahko izkoristi v mikrokrmilnik vgrajeno možnost uporabe prekinitev (ang. interrupt). Slednji način omogoča, da program ves čas, kadar se s tipkami nič ne dogaja izvaja druge operacije, ko pa zazna spremembo stanja, pa skoči v funkcijo za procesiranje tega dogodka.

V mojem primeru sem uporabil kar prvi način, saj za implementacijo potrebuje samo kodo za branje ter procesiranje stanja, ki jo lahko periodično kličem ob vsaki ponovitvi glavne zanke. S tem sicer lahko zamudimo nekatere zelo kratke pritiske, če bi bilo izvajanje glavne zanke časovno predolgo. Ima pa takšen način to prednost, da je predvidljiv in se ne vsiljuje v preostale procese, kot na primer nastavljanje izhodnih vrednosti na DAC, kar se mora zgoditi v dokaj natančnih časovnih intervalih, sicer bi lahko prišlo do popačenj.

Funkcijo, ki prebira tipke in ugotavlja, katere so bile ravnokar pritisnjene in katere ravnokar spuščene, bi lahko struktuiral tako:

\begin{lstlisting}
void buttons_check()
{
	// Staticna spremenljivka hrani prejsnje stanje. Za razliko od globalnih spremenljivk, je ta omejena samo znotraj funkcije in ne "onesnazuje" globalnega dela programa.
	static uint32_t old_state = 0;
	
	// Posamezni biti v spremenljivki predstavljajo tocno doloceno tipko.
	uint32_t state =
		(!ioport_get_pin_level(PIO_PC26_IDX) << 3) |
		(!ioport_get_pin_level(PIO_PC25_IDX) << 2) |
		(!ioport_get_pin_level(PIO_PC24_IDX) << 1) |
		(!ioport_get_pin_level(PIO_PC23_IDX) << 0);
	
	// Izracun spremembe stanj
	uint32_t rising_edge = ~old_state & state;
	uint32_t falling_edge = old_state & ~state;
	
	// Koda, ki ustrezno odreagira na spremembe
	...
	//
	
	// Za konec moramo pripraviti funkcijo za naslednje izvajanje.
	old_state = state;
}
\end{lstlisting}


\subsection{\textit{buttons.h} referenca}

\begin{itemize}
	\item[] \lstinline{void buttons_init(void)}\newline
		Inicializira ustrezne priključke za tipke.
	\item[] \lstinline{void buttons_process(void)}\newline
		Preveri novo stanje tipk in ustrezno reagira na morebitne pritiske.
\end{itemize}



\section{Wi-Fi komunikacija}

S kodo iz prejšnjih razdelkov, sem prišel do neke podlage platforme, na kateri pa sedaj lahko končno začnem graditi še tisti bistveni del projekta, to je komunikacija z brezžičnim omrežjem. Ker krmilnik SAM3X8E oziroma Arduino Due nima nobenega vgrajenega modula za brezžično komunikacijo. Možna je sicer uporaba t. i. Arduino WiFi 101 Shield, ki ima podporo za 5 V in 3.3 V način delovanja, slednji je obvezen za krmilnik na Due, problem pa je, da izdelek ni več v prodaji in niti ni bil precej poceni rešitev (cena naj bi bila okrog 45 EUR).

Zato sem se odločil, da uporabim precej dostopen modul ESP-01, ki ga je možno kupiti relativno poceni (iz uvoza stanejo pod 2 EUR). Na tem modulu je glavna komponenta mikrokrmilnik Espressif ESP8266EX, poleg tega pa običajno vsebujejo še 512 KiB oziroma 1 MiB pomnilnika flash za programiranje. Modul deluje na napetosti 3.3 V, kar pomeni, da je povsem kompatibilen z Due, vsebuje 8 priključkov:

...TODO: slika

Običajno se na takšen modul naloži vmesnik za ukaze AT (ang. AT command set), ti ukazi so poznani tudi kot Hayes command set. Ti ukazi so bili prvotno zasnovani za komunikacijo s telefonskimi modemi, uporabljajo pa se tudi na primer za komunikacijo z GSM modemi. Predvidevam, da je ta način komunikacije precej dober, sicer se ne bi pogosto uporabljal, vendar je lahko problem nepoznavanje nabora ukazov (kot v mojem primeru). Učenje in pisanje ukazov, ki bi omogočali pošiljanje in sprejemanje paketov po brezžičnem omrežju pa je tukaj samo del problema.

Drugi del je to, da bi potreboval izdelati še način oziroma program za komunikacijo s HTTP strežnikom (ang. HTTP client). Sam HTTP protokol je sicer še dokaj enostaven in ga je možno študirati iz prosto dostopnih dokumentov, kot je na primer zdaj že nekoliko zastarel dokument RFC2616, ki predstavlja osnutek Hypertext Transfer Protocol - - HTTP/1.1.

Hkrati pa sem ugotovil, da je proizvajalec samega čipa ESP8266 objavil odprtokodne knjižnice za sam čip ter knjižnice za Arduino med temi knjižnicami pa lahko najdemo med drugim tudi zelo enostavne načine za upravljanje z Wi-Fi funkcionalnostjo na čipu ((to je \textit{ESP8266WiFi.h}) ter za komunikacijo z HTTP strežnikom (to je \textit{ESP8266HTTPClient.h}).

Na podlagi teh ugotovitev sem se odločil za lastno implementacijo "modema", torej kot prvo stvar potrebujem neko enostavno strukturo komunikacije ukazov med moduloma, tako kot ima na primer AT točno definirane strukture ukazov in njegove odzive. Za enostavnost in preglednost sem si zamislil enostavno komunikacijo, v kateri igra Due vlogo glavne naprave (ang. master), ESP-01 pa vlogo podrejene naprave (ang. slave). Torej Due pošilja ukaze v ESP-01, slednji pa mora odgovoriti z ustreznim odgovorom glede na ukaz in v ustreznem času. Vsak ukaz in vsak odgovor (razen določenih izjem), se mora zaključiti z znakom za novo vrstico (ta znak se v programiranju zapiše kot '$\backslash$n'), argumenti ukaza pa so ločeni s presledkom. Iz tega, sem definiral osnovni nabor ukazov:

\begin{footnotesize}
	\begin{center}
		\begin{longtable}{p{0.22\linewidth}|p{0.2\linewidth}|p{0.5\linewidth}}
			\caption{Nabor ukazov za komunikacijo z ESP-01}
			\label{instruction_set_ESP_01} \\
			Ukaz & Odziv & Opis delovanja \\ \hline \hline
			\textit{status} & \textit{OK} & Modul vrne stanje OK v kolikor je pripravljen na sprejem ukazov. \\ \hline
			\textit{connect \%SSID \%PASSWORD} & \textit{OK} oz. besedilo napake & Poskusi se povezati na dostopno točko z nazivom \textit{\%SSID} in geslom \textit{\%PASSWORD},\\ \\
			\multicolumn{3}{l}{\quad Pogoste napake:} \\
			\multicolumn{2}{l|}{\quad\quad \textit{Connection failed. SSID is empty}} & Manjka ime omrežja \\
			\multicolumn{2}{l|}{\quad\quad \textit{Connection failed. Password is empty}} & Manjka geslo \\
			\multicolumn{2}{l|}{\quad\quad \textit{Connection failed}} & Povezava ni uspela \\
			\multicolumn{2}{l|}{\quad\quad \textit{Connection timed out}} & Povezovanje je trajalo predolgo \\ \hline
			\textit{play\_next} & \textit{OK} & Pošlje ukaz za prestavitev na naslednji posnetek v vrsti na strežnik \\ \hline
			\textit{play\_previous} & \textit{OK} & Pošlje ukaz za prestavitev na prejšnji posnetek v vrsti na strežnik \\ \hline
			\textit{get\_currently\_playing} &  & Pridobi informacije o trenutnem posnetku iz strežnika \\ \\
			& \textit{OK PLAYING \{0\};\{1\};\{2\};\{3\}} & Informacije so pridobljene \\
			\multicolumn{3}{l}{\quad Argumenti:} \\
			\multicolumn{2}{l|}{\quad\quad \textit{\{0\}}} & Dolžina posnetka v ms \\
			\multicolumn{2}{l|}{\quad\quad \textit{\{1\}}} & Frekvenca vzorčenja v Hz \\
			\multicolumn{2}{l|}{\quad\quad \textit{\{2\}}} & Trenutni odsek (current chunk) \\
			\multicolumn{2}{l|}{\quad\quad \textit{\{3\}}} & Število odsekov (total chunks) \\ \
			& \textit{OK STOPPED} & Predvajanje je ustavljeno \\ \\
			& \textit{FAIL} & Napaka pri pridobivanju podatkov \\ \hline
			
			\textit{get\_track\_info \%ID} &  & Pridobi informacije o posnetku z identifikatorjem \%ID iz strežnika \\ \\
			& \textit{OK \{0\};\{1\}} & Informacije so pridobljene \\
			\multicolumn{3}{l}{\quad Argumenta:} \\
			% \multicolumn{2}{l|}{\quad\quad \textit{\{0\}}} & Dolžina posnetka v ms \\
			\multicolumn{2}{l|}{\quad\quad \textit{\{0\}}} & Frekvenca vzorčenja v Hz \\
			\multicolumn{2}{l|}{\quad\quad \textit{\{1\}}} & Število odsekov (total chunks) \\ \\
			& \textit{FAIL} & Napaka pri pridobivanju podatkov \\ \hline
			
			\textit{get\_chunk \%ID \%CHUNK\_INDEX} &  & Prenesi zahtevani odsek \%CHUNK\_INDEX posnetka \%ID iz strežnika \\ \\
			& \textit{OK \{0\}}, nato podatki & Odsek uspešno prenešen \\
			\multicolumn{3}{l}{\quad Argumenti:} \\
			\multicolumn{2}{l|}{\quad\quad \textit{\{0\}}} & Dolžina podatkov \\
			\multicolumn{2}{l|}{\quad\quad podatki} & Podatki so celoštevilske vrednosti signala \\ \\
			& \textit{FAIL} & Napaka pri pridobivanju podatkov \\ \hline
			
			\textit{get\_current\_time} &  & Pridobi trenutni čas iz strežnika \\ \\
			& \textit{OK YYYY-MM-DD HH:mm:ss} & Čas pridobljen \\ \\
			& \textit{FAIL} & Napaka pri pridobivanju podatkov \\ \hline
		\end{longtable}
	\end{center}
\end{footnotesize}

V podprojektu modem-esp8266 sem nato upoštevajoč zgornje definicije razvil program, ki preko serijskega vmesnika prebira podatke in ob vsakem znaku '\\n' izvede ustrezen ukaz. Ukazi na strežnik uporabljajo \textit{HTTPClient}, ki omogoča pošiljanje zahtev na strežnik in enostavno branje odziva. Na drugi strani pa je Due s projektom due-radio, v katerega sem dodal gonilnik \textit{esp\_module.h} za komnikacijo z modulom. Pri tem sem uporabil precej podoben način komunikacije kot že prej za implementacijo konzole. Podobno kot pri gonilniku za LCD zaslon, kjer sem smiselno ločil visokonivojske operacije od nizkonivojskih. Tu predstavljajo visokonivojske operacije ukazi za inicializacijo ter funkcije, ki poenostavijo pošiljanje ukazov iz definicij ter njihov sprejem. Nizkonivojske operacije pa uporabljajo predponi \textit{esp\_module\_rx\_} in \textit{esp\_module\_tx\_} in so namenjene neposrednemu pošiljanju podatkov v in iz modula.

Pri vračanju podatkov pa sem definiral še določene strukture na primer za informacije o posnetku in času, ki jih visokonivojske funkcije ustrezno uporabijo in mi omogoča hitro uporabo v drugih delih kode:

\begin{lstlisting}
// Podatki o dolocenem posnetku
typedef struct {
	//char* track_path;  // Trenutno ni implementirano
	int32_t track_length_ms;    // Dolzina posnetka v ms
	int32_t sampling_frequency; // Frekvenca vzorcenja v Hz
	int32_t total_chunks;       // Skupno stevilo odsekov
} track_info;

// Podatki o posnetku, ki se trenutno predvaja na strezniku
typedef struct {
	track_info track;      // Podatki o posnetku
	int32_t current_chunk; // Trenuten odsek
} currently_playing_info;

// Trenuten cas, razdeljen v locene spremenljivke
typedef struct {
	int year;
	int month;
	int day;
	int hour;
	int minutes;
	int seconds;
} current_time;
\end{lstlisting}


\subsection{\textit{esp\_module.h} referenca}

\begin{itemize}
	\item[] \lstinline{void esp_module_hardware_setup(lcd_t* lcd_ptr)}\newline
	Inicializira strojno opremo ESP modula, vhodni parameter \lstinline{lcd_ptr} je privzeti LCD zaslon, na katerega naj se izpišejo morebitne napake.
	\item[] \lstinline{bool esp_module_init(void)}\newline
	Poskusi inicializirati ESP modul z ukazom \textit{status}.
	\item[] \lstinline{bool esp_module_wifi_connect(const char* ssid, const char* password)}\newline
	Začne povezavo na brezžično omrežje.
	\item[] \lstinline{void esp_module_play_next()}\newline
	Pošlje ukaz za naslednji posnetek.
	\item[] \lstinline{void esp_module_play_previous()}\newline
	Pošlje ukaz za prejšnji posnetek.
	\item[] \lstinline{currently_playing_info* esp_module_get_currently_playing()}\newline
	Pridobi informacije o posnetku, ki se trenutno predvaja. V kolikor se ne predvaja, oziroma je prišlo do napake, bo vrnjen kazalec enak \lstinline{NULL}.
	\item[] \lstinline{track_info* esp_module_get_track_info(int track_id)}\newline
	Pridobi informacije o izbranem posnetku. V kolikor je prišlo do napake, bo vrnjen kazalec enak \lstinline{NULL}.
	\item[] \lstinline{uint8_t* esp_module_get_chunk(int track_id, int chunk_index)}\newline
	Začne prenos segmenta izbranega posnetka. Dolžina segmenta se shrani in podatki se zapisujejo v FIFO vrsto, dokler niso vsi prebrani. Med branjem ni možna prekinitev.
	\item[] \lstinline{current_time* esp_module_get_current_time()}\newline
	Pridobi informacijo o trenutnem času s strežnika. V kolikor je prišlo do napake, bo vrnjen kazalec enak \lstinline{NULL}.
\end{itemize}



\section{Implementacija predvajalnika glasbe}

--------------------------TODO!!!!




\section{Strežnik za glasbo (projekt wav-server)}

Zadnja problematika kar se programiranja tiče, je izdelava programa, na katerega se bo lahko modul povezal in z njim komuniciral. Uporabil sem platformo Node.js in skriptni jezik TypeScript. Znotraj tega pa sem uporabil knjižnice \textit{express} za HTTP strežnik, \textit{moment} za formatiranje časa, \textit{wavefile} za nalaganje in ustrezno preoblikovanje zvočnega signala. 

Opažam, da se programi v skriptnih jezikih precej hitro zakomplicirajo in celotna koda v eni datoteki postane zelo nepregledna. Zato sem ta podprojekt razdelil v več datotek:

\begin{itemize}
	\item \textit{main.ts}
	Zagonska skripta programa, naloži konstante za seznam predvajanja, nastavitve strežnika in zažene strežnik.
	\item \textit{wavserver.ts}
	HTTP strežnik, sprejema zahteve, jih ustrezno izvede in vrne HTTP odziv.
	\item \textit{Streamer.ts}
	Streamer je mišljeno v tem smislu, da skrbi za seznam predvajanja, ustrezno distribuiranje segmentov posnetka večim poslušalcem (v kolikor je to ustrezno implementirano) in ustrezno nadaljevanje na naslednji segment posnetka.
	\item \textit{Playlist.ts}
	Seznam predvajanja skrbi za pripravo posnetkov iz seznama, hranjenje podatkov o trenutnem posnetku in premikanju po seznamu (naslednji, prejšnji posnetek). V tej datoteki se nahaja tudi definicija elementa iz seznama predvajanja, ki vsebuje posnetek (Track).
	\item \textit{Track.ts}
	Track oziroma posnetek je objekt, ki vsebuje različne podatke o posnetku (pot do datoteke, frekvenca vzorčenja, velikost segmentov, število segmentov), poleg tega pa hrani tudi celoten posnetek v obliki 8-bitnih števil, ki se ga uporablja za rezanje na segmente. Poskrbi pa tudi za nalaganje podatkov iz datoteke in pretvorbo v ustrezno obliko (8-bitna globina z ustrezno frekvenco vzorčenja).
	\item \textit{config.ts}
	Datoteka, ki hrani konfiguracijo strežnika. Ta datoteka naj bo kopirana iz datoteke \textit{config.ts.example}, saj ni shranjena v orodju za beleženje zgodovine. Potrebno je dodati tudi zvočne posnetke, najboljše je ustvariti mapo \textit{music} v isti mapi kot config.ts in posnetke dodati v to mapo. V konfiguraciji je potrebno navesti pot do vsakega od posnetekov.
\end{itemize}



\section{Sestavljanje \textit{main.c}}

Zdaj je večina programskega dela končno napisana, manjka pa samo še dejanski program na mikrokrmilniku, ki bo vse skupaj povezal in začel predvajati glasbo. 

To bo naloga datoteke \textit{main.c}, v projektu due-radio. V njej se nahaja funkcija \lstinline{int main(void)}, ki je vstopna točka programa in se zažene z mikrokrmilnikom. Tu bo torej potrebno inicializirati vso potrebno strojno opremo, se povezati na omrežje in poskrbeti, da predvajanje normalno deluje.

V smislu Arduino programiranja, sem si funkcijo \textit{main} razširil na funkcijo za inicializacijo \lstinline{bool boot_setup(void)} ter na glavno neskončno zanko \lstinline{void main_loop(void)}. Znotraj funkcije \textit{main} tako kličem funkcijo \textit{boot\_setup} in preverim njen rezultat. V primeru, da je bil zagon neuspešen, sem se odločil da implementiram enostaven mehanizem, ki krmilnik resetira in ponovno preizkusi zagon po nekem določenem času (na primer po 10 sekundah). Koda v \textit{main} funkciji izgleda približno tako:

\begin{lstlisting}
int main(void)
{
	...
	// Na zacetku je inicializacija mikrokrmilnika za pravilno delovanje
	
	// Zagon sistema
	bool setup_successful = boot_setup();
	if (setup_successful)
	{
		// Zagon uspesen.
		
		while (1)
		{
			// Izvajanje programa v glavni zanki.
			main_loop();
		}
	}
	else
	{
		// Zagon neuspesen.
		delay_ms(3000);
		lcd_write_upper_formatted(&lcd, "Boot setup fail");
		lcd_write_lower_formatted(&lcd, "Cannot continue");
		
		console_put_line(CONSOLE_VT100_COLOR_TEXT_RED
		"\n\nBoot setup has failed...\nCannot continue." CONSOLE_VT100_COLOR_TEXT_DEFAULT);
		
		console_put_line(CONSOLE_VT100_COLOR_TEXT_RED
		"Resetting in 10 seconds." CONSOLE_VT100_COLOR_TEXT_DEFAULT);
		
		delay_ms(10000);
		
		// Koda za ponoven zagon sistema
		__DSB;
		SCB->AIRCR = ((0x5FA << SCB_AIRCR_VECTKEY_Pos) | SCB_AIRCR_SYSRESETREQ_Msk);
		RSTC->RSTC_CR = RSTC_CR_KEY(0xA5) | RSTC_CR_PERRST | RSTC_CR_PROCRST;
		NVIC_SystemReset();
		
		// Prepreci izvajanje cesarkoli drugega pred ponastavitvijo
		while (1)
		{
		}
	}
	
	while (1); // Backup
}
\end{lstlisting}

Kar se tiče zagona sistema, si procesi sledijo v naslednjem vrstnem redu:

\begin{enumerate}
	\item Inicializacija osnovne strojne opreme mikrokrmilnika (delay, ioport, timeguard).
	\item Inicializacija gonilnika za tipke.
	\item Inicializacija LCD zaslona in prikaz osnovnih informacij.
	\item Inicializacija serijske konzole in izpis pozdravnega sporočila.
	\item Inicializacija gonilnika za digitalno-analogni pretvornik (DAC).
	\item Inicializacija ESP-01 modula.
	\item Povezovanje v Wi-Fi omrežje.
	\item Sinhronizacija trenutnega časa.
\end{enumerate}

V glavni zanki pa se periodično izvajajo naslednja opravila:

\begin{enumerate}
	\item Procesiranje pritiskov na tipke.
	\item Procesiranje vhodov iz konzole (sistem še ni implementiran, saj ni zanesljiv).
	\item TODO: Izvajanje predvajalnika glasbe.
	\item TODO: Posodobitev časa / prikaz na zaslonu.
\end{enumerate}



\end{document}
